<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>mdBook 中文指南 （非官方）</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Create book from markdown files. Like Gitbook but implemented in Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">简介</a></li><li class="chapter-item expanded affix "><li class="part-title">使用指南</li><li class="chapter-item expanded "><a href="guide/installation.html"><strong aria-hidden="true">1.</strong> 安装</a></li><li class="chapter-item expanded "><a href="guide/reading.html"><strong aria-hidden="true">2.</strong> 阅读mdBook生成的图书</a></li><li class="chapter-item expanded "><a href="guide/creating.html"><strong aria-hidden="true">3.</strong> 通过mdBook制作图书</a></li><li class="chapter-item expanded affix "><li class="part-title">参考指南</li><li class="chapter-item expanded "><a href="cli/index.html"><strong aria-hidden="true">4.</strong> 命令行工具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cli/init.html"><strong aria-hidden="true">4.1.</strong> init</a></li><li class="chapter-item expanded "><a href="cli/build.html"><strong aria-hidden="true">4.2.</strong> build</a></li><li class="chapter-item expanded "><a href="cli/watch.html"><strong aria-hidden="true">4.3.</strong> watch</a></li><li class="chapter-item expanded "><a href="cli/serve.html"><strong aria-hidden="true">4.4.</strong> serve</a></li><li class="chapter-item expanded "><a href="cli/test.html"><strong aria-hidden="true">4.5.</strong> test</a></li><li class="chapter-item expanded "><a href="cli/clean.html"><strong aria-hidden="true">4.6.</strong> clean</a></li><li class="chapter-item expanded "><a href="cli/completions.html"><strong aria-hidden="true">4.7.</strong> completions</a></li></ol></li><li class="chapter-item expanded "><a href="format/index.html"><strong aria-hidden="true">5.</strong> Format</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="format/summary.html"><strong aria-hidden="true">5.1.</strong> SUMMARY.md</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.1.</strong> Draft chapter</div></li></ol></li><li class="chapter-item expanded "><a href="format/configuration/index.html"><strong aria-hidden="true">5.2.</strong> 配置</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="format/configuration/general.html"><strong aria-hidden="true">5.2.1.</strong> General</a></li><li class="chapter-item expanded "><a href="format/configuration/preprocessors.html"><strong aria-hidden="true">5.2.2.</strong> Preprocessors</a></li><li class="chapter-item expanded "><a href="format/configuration/renderers.html"><strong aria-hidden="true">5.2.3.</strong> Renderers</a></li><li class="chapter-item expanded "><a href="format/configuration/environment-variables.html"><strong aria-hidden="true">5.2.4.</strong> Environment Variables</a></li></ol></li><li class="chapter-item expanded "><a href="format/theme/index.html"><strong aria-hidden="true">5.3.</strong> Theme</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="format/theme/index-hbs.html"><strong aria-hidden="true">5.3.1.</strong> index.hbs</a></li><li class="chapter-item expanded "><a href="format/theme/syntax-highlighting.html"><strong aria-hidden="true">5.3.2.</strong> Syntax highlighting</a></li><li class="chapter-item expanded "><a href="format/theme/editor.html"><strong aria-hidden="true">5.3.3.</strong> Editor</a></li></ol></li><li class="chapter-item expanded "><a href="format/mathjax.html"><strong aria-hidden="true">5.4.</strong> MathJax Support</a></li><li class="chapter-item expanded "><a href="format/mdbook.html"><strong aria-hidden="true">5.5.</strong> mdBook-specific features</a></li><li class="chapter-item expanded "><a href="format/markdown.html"><strong aria-hidden="true">5.6.</strong> Markdown</a></li></ol></li><li class="chapter-item expanded "><a href="continuous-integration.html"><strong aria-hidden="true">6.</strong> 持续集成</a></li><li class="chapter-item expanded "><a href="for_developers/index.html"><strong aria-hidden="true">7.</strong> For Developers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="for_developers/preprocessors.html"><strong aria-hidden="true">7.1.</strong> Preprocessors</a></li><li class="chapter-item expanded "><a href="for_developers/backends.html"><strong aria-hidden="true">7.2.</strong> Alternative Backends</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="misc/contributors.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">mdBook 中文指南 （非官方）</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/xihaduanzi/mdBook_guide_cn" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h3 id="注释"><a class="header" href="#注释">注释</a></h3>
<p><strong>这是 mdbook document 的非官方中文翻译版本，根据<a href="https://rust-lang.github.io/mdBook/">mdBook document(official)</a>  <a href="https://github.com/rust-lang/mdBook">GitHub</a>  版本 0.4.18 翻译</strong></p>
<h1 id="简介"><a class="header" href="#简介">简介</a></h1>
<p>mdBook是一个通过Markdown制作图书的命令行工具软件。它非常适合创建产品说明或API文档、教程、课程教材或任何需要清晰、易于导航和可定制的演示文稿。</p>
<ul>
<li>轻量级的<a href="format/markdown.html">Markdown</a>语法帮助你聚焦写作</li>
<li>集成的<a href="guide/reading.html#search">搜索</a>功能支持</li>
<li>支持多种编程语言代码块的<a href="format/theme/syntax-highlighting.html">语法高亮</a></li>
<li><a href="format/theme/index.html">主题</a>文件允许自定义输出的格式</li>
<li><a href="format/configuration/preprocessors.html">预处理</a>能够为自定义语法和内容修改提供扩展</li>
<li><a href="format/configuration/renderers.html">后端</a>可以将输出多种格式文件</li>
<li>由高效、安全、简单的<a href="https://www.rust-lang.org/">Rust</a>语言编写</li>
<li>自动对<a href="cli/test.html">Rust代码示例</a>进行测试</li>
</ul>
<p>本指南就是由 mdBook 生成的一个示例。同时mdBook也被Rust语言项目使用，而 <a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a> 这本书也是mdBook生成的另一个很好的示例。</p>
<h2 id="贡献"><a class="header" href="#贡献">贡献</a></h2>
<p>mdBook是免费的开源的。您可以在
<a href="https://github.com/rust-lang/mdBook">GitHub</a>找到源代码，同时您也可以将问题和功能请求发布在
<a href="https://github.com/rust-lang/mdBook/issues">GitHub issue tracker</a>。mdBook 依靠社区来修复错误和
添加功能：如果您想做出贡献，请阅读
<a href="https://github.com/rust-lang/mdBook/blob/master/CONTRIBUTing.md">CONTRIBUTE</a> 指南，并考虑是否提交一个 <a href="https://github.com/rust-lang/mdBook/pulls">拉取请求</a>。</p>
<h2 id="许可协议"><a class="header" href="#许可协议">许可协议</a></h2>
<p>mdBook 源代码及文档基于 <a href="https://www.mozilla.org/MPL/2.0/">Mozilla Public License v2.0</a>发布.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安装"><a class="header" href="#安装">安装</a></h1>
<p>这里由很多途径来安装mdBook命令行工具。您可以选择最适合您的方式进行安装。如果你想通过自动部署的方式来使用 mdbook ,可以参考<a href="guide/../continuous-integration.html">持续集成</a>的章节更多的示例。</p>
<h2 id="已经编译的可执行程序"><a class="header" href="#已经编译的可执行程序">已经编译的可执行程序</a></h2>
<p>可以在<a href="https://github.com/rust-lang/mdBook/releases">GitHub Releases page</a>下载适用于您使用操作系统的可执行文件（Windows,macOS or Linux）以及源代码的压缩文件。</p>
<p>为了方便使用，建议将执行文件的路径添加到您的PATH路径上</p>
<h2 id="通过rust编译源代码的方式构建"><a class="header" href="#通过rust编译源代码的方式构建">通过Rust编译源代码的方式构建</a></h2>
<p>为了通过源代码编译的方式生成mdbook程序，您首先需要安装Rust 程序 和 Cargo.可以参考 <a href="https://www.rust-lang.org/tools/install">Rust installation page</a>.注意 mdbook 需要 Rust 版本在1.54 以上。</p>
<p>安装Rust程序以后，可以通过下面的命令编译及安装 mdBook：</p>
<pre><code class="language-sh">cargo install mdbook
</code></pre>
<p>cargo 将自动从 <a href="https://crates.io/">crates.io</a>下载mdBook 源代码，进行编译和安装。生成的可执行文件被生成在 Cargo全局执行目录 (<code>~/.cargo/bin/</code> 默认).</p>
<h3 id="安装最新版本"><a class="header" href="#安装最新版本">安装最新版本</a></h3>
<p>在 crates.io上发布的mdbook 不是最新版本的（略低于最新版本），如果需要最新版本可以通过Cargo 从 GitHub  构建最新的版本，这是非常容易的，运行下面的命令：</p>
<pre><code class="language-sh">cargo install --git https://github.com/rust-lang/mdBook.git mdbook
</code></pre>
<p>在运行cargo前，一定要确认 cargo 可执行路径已经加到您的 PATH 里</p>
<p>如果您有兴趣对 mdBook 本身进行修改，请查看 <a href="https://github.com/rust-lang/mdBook/blob/master/CONTRIBUTING.md">贡献指南</a> 了解更多信息。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="阅读mdbook生成的图书"><a class="header" href="#阅读mdbook生成的图书">阅读mdBook生成的图书</a></h1>
<p>本章介绍了如何与 mdBook 制作的图书进行交互。假设您正在阅读一本 HTML 书籍。这相对于其他输出格式（如 PDF），选项和格式将有所不同。</p>
<p>电子书是由章节组成的。每章都是一个单独的页面。章节可以嵌套子章节。通常，每个章节将组织成一系列标题以细分一章。</p>
<h2 id="导航"><a class="header" href="#导航">导航</a></h2>
<p>有很多途径可以导航到图书的章节</p>
<p>左侧的<strong>侧边栏</strong>提供了所有章节的列表。
点击任何章节标题将显示这一章节。</p>
<p>如果窗口太窄，边栏可能不会自动显示，尤其是在移动端上。
在这种情况下，可以按下页面左上角的菜单图标（三个水平条 类似粗体 “<strong>三</strong>”）以打开和关闭侧边栏。</p>
<p>正文页面底部的箭头按钮可用于导航到上一章或下一章。</p>
<p>键盘上的<strong>向左和向右箭头键</strong>也可用于导航到上一章或下一章。</p>
<h2 id="顶部菜单条"><a class="header" href="#顶部菜单条">顶部菜单条</a></h2>
<p>在页面顶部的菜单条提供了一些图标，用于与图书的交互。下方展示的图标是否显示，取决于图书生成时的制作设定。</p>
<table><thead><tr><th>图标</th><th>说明</th></tr></thead><tbody>
<tr><td><i class="fa fa-bars"></i></td><td>打开或关闭显示章节列表的侧边栏。</td></tr>
<tr><td><i class="fa fa-paint-brush"></i></td><td>打开颜色主题列表</td></tr>
<tr><td><i class="fa fa-search"></i></td><td>打开搜索框，对全书内容进行搜索</td></tr>
<tr><td><i class="fa fa-print"></i></td><td>打开 浏览器打印预览界面，打印整本书。</td></tr>
<tr><td><i class="fa fa-github"></i></td><td>打开指向托管图书源代码的网站的链接。</td></tr>
<tr><td><i class="fa fa-edit"></i></td><td>打开一个页面以直接编辑您当前正在阅读的页面的源代码。</td></tr>
</tbody></table>
<p>点击菜单栏（除去图标的地方）会将页面滚动到顶部。</p>
<h2 id="搜索"><a class="header" href="#搜索">搜索</a></h2>
<p>每本书都有一个内置的搜索系统。
按菜单栏中的搜索图标（<i class="fa fa-search"></i>）或按键盘上的“S”键将打开一个输入框，用于输入搜索词。
键入某些术语将实时显示匹配的章节和部分。</p>
<p>点击任何搜索处的结果都将跳转到该部分。
向上和向下箭头键可用于导航结果，Enter 将打开突出显示的部分。</p>
<p>加载搜索结果后，匹配的搜索词将在文本中突出显示。单击突出显示的单词或按 Esc 键将删除突出显示。</p>
<h2 id="代码块"><a class="header" href="#代码块">代码块</a></h2>
<p>mdBook 制作的书籍通常用于编程项目，因此它支持突出显示代码块和示例。
代码块可能包含几个不同样式的图标，用于读者与它们进行交互：</p>
<table><thead><tr><th>Icon</th><th>Description</th></tr></thead><tbody>
<tr><td><i class="fa fa-copy"></i></td><td>将代码块复制到本地剪贴板中，允许复制粘贴到另一个应用程序中。</td></tr>
<tr><td><i class="fa fa-play"></i></td><td>对于 Rust 代码示例，点击后将执行示例代码，并在示例下方显示输出结果。(see <a href="guide/../format/mdbook.html#rust-playground">playground</a>).</td></tr>
<tr><td><i class="fa fa-eye"></i></td><td>对于 Rust 代码示例，这将显示或隐藏“隐藏”代码的可见性。有时，较大的示例会隐藏与所说明内容不是特别相关的行。 (参考 <a href="guide/../format/mdbook.html#hiding-code-lines">hiding code lines</a>).</td></tr>
<tr><td><i class="fa fa-history"></i></td><td>对于 <a href="guide/../format/theme/editor.html">可编辑的代码示例</a>，这将撤消您所做的任何更改。</td></tr>
</tbody></table>
<p>下面时一个简单的例子:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;Hello, World!&quot;);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="通过mdbook制作图书"><a class="header" href="#通过mdbook制作图书">通过mdBook制作图书</a></h1>
<p>一旦您已经安装了mdbook命令行工具，那么您可以使用它创建或渲染您的图书</p>
<h2 id="初始化开始制作图书"><a class="header" href="#初始化开始制作图书">初始化开始制作图书</a></h2>
<p><code>mdbook init</code> 命令将创建一个包含空书的新目录，供您开始使用。<code>my-first-book</code>是为其指定要创建的目录的名称：</p>
<pre><code class="language-sh">mdbook init my-first-book
</code></pre>
<p>在生成书籍之前，它会问几个问题.回答完问题后，初始化完成。您可以进入新生成的目录：</p>
<pre><code class="language-sh">cd my-first-book
</code></pre>
<p>有几种方法可以渲染一本书，但最简单的方法之一是使用“serve”命令，这将自动构建你的书并启动本地Web服务器：</p>
<pre><code class="language-sh">mdbook serve --open
</code></pre>
<p>--open 选项将打开默认的 Web 浏览器以查看新图书。即使在编辑书籍内容时，您也可以让服务器保持运行状态，mdbook将自动重建输出并自动刷新Web浏览器。</p>
<p>查看 <a href="guide/../cli/index.html">CLI Guide</a> 可以获取更多的<code>mdbook</code> 命令和CLI 选项</p>
<h2 id="mdbook-图书构建细节"><a class="header" href="#mdbook-图书构建细节">mdbook 图书构建细节</a></h2>
<p>mdbook制作的图书是由几个文件构建的，这些文件定义了书的设置和布局。</p>
<h3 id="booktoml"><a class="header" href="#booktoml"><code>book.toml</code></a></h3>
<p>在您的创建图书的根目录下，有一个 <code>book.toml</code>  文件，这个文件用来表述如何构建书籍的设置。这是用<a href="https://toml.io/">TOML标记语言</a>编写的。
默认设置通常足以让你入门。
当您有兴趣探索 mdBook 提供的更多功能和选项时，请查看 <a href="guide/../format/configuration/index.html">配置章节</a> 了解更多详情。</p>
<p>一个非常简单的 <code>book.toml</code> 像下面的例子:</p>
<pre><code class="language-toml">[book]
title = &quot;My First Book&quot;
</code></pre>
<h3 id="summarymd"><a class="header" href="#summarymd"><code>SUMMARY.md</code></a></h3>
<p>另外一个主要部分是位于 <code>src/SUMMARY.md</code> 的摘要文件。此文件包含本书中所有章节的列表。必须先将某一章添加到此列表中，然后才能查看该章。</p>
<p>下面是一个包含几个章节的基本摘要文件示例：</p>
<pre><code class="language-md"># Summary

[Introduction](README.md)

- [My First Chapter](my-first-chapter.md)
- [Nested example](nested/README.md)
    - [Sub-chapter](nested/sub-chapter.md)
</code></pre>
<p>可以尝试用在你的编辑器中打开 src/SUMMARY.md 并添加一些章节。如果任何章节文件不存在，mdbook将自动为您创建它们。</p>
<p>有关摘要文件的其他格式设置选项的更多详细信息，请查看 <a href="guide/../format/summary.html">SUMMARY.md</a> 章节.</p>
<h3 id="源文件"><a class="header" href="#源文件">源文件</a></h3>
<p>您的图书内容都包含在<code>src</code>目录中。
每个章节都是一个单独的 Markdown 文件。
通常，每章都以 H1 级标题和章节标题开头。</p>
<pre><code class="language-md"># My First Chapter

Fill out your content here.
</code></pre>
<p>文件的精确布局取决于您。文件的组织将与生成的 HTML 文件相对应，因此请记住，文件布局是每个章节 URL 的一部分。</p>
<p>当 mdbook serve 命令正在运行时，您可以打开任何章节文件并开始编辑它们。每次保存文件时，mdbook都会重建书籍并刷新您的Web浏览器。</p>
<p>查看  <a href="guide/../format/markdown.html">Markdown chapter</a> 章节，了解有关设置章节内容格式的更多信息。</p>
<p><code>src</code> 目录中的所有其他文件都将包含在输出中。因此，如果您有图像或其他静态文件，只需将它们包含在<code>src</code>目录中的某个位置即可。</p>
<h2 id="发布图书"><a class="header" href="#发布图书">发布图书</a></h2>
<p>一旦您写完书后，您可能希望将其托管在某个地方供其他人查看。
第一步是建立这本书的输出。
这可以通过<code>book.toml</code>文件所在的同一目录中的<code>mdbook build</code>命令来完成：</p>
<pre><code class="language-sh">mdbook build
</code></pre>
<p>这将生成一个名为<code>book</code>的目录，其中包含您图书的全部HTML内容。
然后，您可以将此目录<code>book</code> 里面的内容放在任何 Web 服务器上以托管它。</p>
<p>有关发布和部署的详细信息，请查看<a href="guide/../continuous-integration.html">持续集成章节</a> 了解更多信息。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-tool-命令行工具"><a class="header" href="#command-line-tool-命令行工具">Command Line Tool 命令行工具</a></h1>
<p><code>mdbook</code> 命令行工具用于创建和构建书籍。<a href="cli/(../guide/installation.html">安装</a> mdbook 后，可以在终端中运行 <code>mdbook</code> 帮助命令以查看可用的命令。</p>
<p>以下各节提供有关不同命令的详细解释。</p>
<ul>
<li><a href="cli/init.html"><code>mdbook init &lt;directory&gt;</code></a> — 初始化新书，并提供简单的模板</li>
<li><a href="cli/build.html"><code>mdbook build</code></a> — 生成图书.</li>
<li><a href="cli/watch.html"><code>mdbook watch</code></a> — 每当源文件发生更改时，重新生成图书。</li>
<li><a href="cli/serve.html"><code>mdbook serve</code></a> — Runs a web server to view the book, and rebuilds on changes.</li>
<li><a href="cli/test.html"><code>mdbook test</code></a> — Tests Rust code samples.</li>
<li><a href="cli/clean.html"><code>mdbook clean</code></a> — Deletes the rendered output.</li>
<li><a href="cli/completions.html"><code>mdbook completions</code></a> — Support for shell auto-completion.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-init-command-初始化命令"><a class="header" href="#the-init-command-初始化命令">The init command 初始化命令</a></h1>
<p>每本新书都有共性的样板，因此 mdbook 提供了 <code>init</code> 命令</p>
<p><code>init</code> 像下面这样:</p>
<pre><code class="language-bash">mdbook init
</code></pre>
<p>首次使用<code>init</code>命令时，将自动生成设置几个文件和文件夹</p>
<pre><code class="language-bash">book-test/
├── book
└── src
    ├── chapter_1.md
    └── SUMMARY.md
</code></pre>
<ul>
<li><code>src</code>目录是你用markdown写书的地方。它包含所有源文件，配置文件等。</li>
<li><code>book</code>目录是图书的生成呈现位置。所有输出内容可以
上传到服务器，供您的读者阅读。</li>
<li><code>SUMMARY.md</code> 规划您图书的结构，并更详细地讨论<a href="cli/../format/summary.html">在另一
章</a>.</li>
</ul>
<h4 id="提示从-summarymd-生成章节"><a class="header" href="#提示从-summarymd-生成章节">提示：从 SUMMARY.md 生成章节</a></h4>
<p>当<code>SUMMARY.md</code> 文件已存在时，<code>init</code> 命令将首先解析它
并根据<code>SUMMARY.md</code>中使用的路径生成丢失或者不存在的文件。
这使您可以思考并创建书籍的整个结构，然后
让 mdBook 为您生成它。</p>
<h4 id="指定目录"><a class="header" href="#指定目录">指定目录</a></h4>
<p><code>init</code>命令可以将目录作为参数，以用作书籍的根目录
而不是当前的工作目录。</p>
<pre><code class="language-bash">mdbook init path/to/book
</code></pre>
<h4 id="--theme"><a class="header" href="#--theme">--theme</a></h4>
<p>当您使用<code>--theme</code> 参数时，默认主题将被复制到
源目录中名为<code>theme</code>的目录，以便您可以对其进行修改。</p>
<p>主题被选择性地覆盖，这意味着如果你不想
覆盖特定文件，只需将其删除，即可使用默认文件。</p>
<h4 id="--title"><a class="header" href="#--title">--title</a></h4>
<p>指定图书的标题。如果未提供，交互式提示将要求输入
标题。</p>
<pre><code class="language-bash">mdbook init --title=&quot;my amazing book&quot;
</code></pre>
<h4 id="--ignore"><a class="header" href="#--ignore">--ignore</a></h4>
<p>创建一个“.gitignore”文件，该文件配置为忽略<a href="cli/build.html">building</a>书籍时创建的“书籍”目录。
如果未提供，将出现一个交互式提示，询问是否应创建它。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-build-command-构建命令"><a class="header" href="#the-build-command-构建命令">The build command 构建命令</a></h1>
<p>build 命令用于渲染您的图书:</p>
<pre><code class="language-bash">mdbook build
</code></pre>
<p>它将尝试解析您的<code>SUMMARY.md</code>文件，以了解书的结构
并据此获取相应的文件。请注意，<code>SUMMARY.md</code>中提到的文件如果不存此
是会自动创建的。</p>
<p>为方便起见，输出结果将保持与源相同的目录结构。因此，大本书籍在渲染时将保持结构化。</p>
<h4 id="指定目录-1"><a class="header" href="#指定目录-1">指定目录</a></h4>
<p><code>build</code>命令可以将指定目录作为参数，用来告知<code>build</code>书籍的根目录，而不是当前工作目录。</p>
<pre><code class="language-bash">mdbook build path/to/book
</code></pre>
<h4 id="--open"><a class="header" href="#--open">--open</a></h4>
<p>当您使用<code>--open</code>（<code>-o</code>）标志时，mdbook将在
构建后，打开默认Web浏览器显示生成效果。</p>
<h4 id="--dest-dir"><a class="header" href="#--dest-dir">--dest-dir</a></h4>
<p><code>--dest-dir</code> (<code>-d</code>) 选项，允许您改变您的图书输出路径。注意如果是相对路径，则相对的是图书的根目录。如果没有指定 <code>--dest-dir</code> (<code>-d</code>)，则 <code>--dest-dir</code> (<code>-d</code>)的路径是在<code>book.toml</code>指定的，一般是 <code>./book</code></p>
<hr />
<p><em><strong>注意:</strong></em> *build 命令将从源目录中复制所有文件（但不包括扩展名为 “.md” 的文件）
到构建目录中。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-watch-command-监控命令"><a class="header" href="#the-watch-command-监控命令">The watch command 监控命令</a></h1>
<p>当您希望实时在图书目录下的任何一个文件发生变化时，可以自动重新构建的的话，<code>watch</code> 命令是非常有效的。这样您可以不必重复的使用 <code>mdbook build</code>  命令。另外，在因为文件发生变化触发重建的时候，同样会重建在 <code>SUMMARY.md</code> 记录但实际上不存在的文件</p>
<h4 id="指定目录-2"><a class="header" href="#指定目录-2">指定目录</a></h4>
<p><code>watch</code>命令可以将目录作为参数用于指定书籍的
根目录而不是当前工作目录。</p>
<pre><code class="language-bash">mdbook watch path/to/book
</code></pre>
<h4 id="--open-1"><a class="header" href="#--open-1">--open</a></h4>
<p>当您使用<code>--open</code>（<code>-o</code>）选项时，mdbook将在重构后，打开
您的默认网络浏览器。</p>
<h4 id="--dest-dir-1"><a class="header" href="#--dest-dir-1">--dest-dir</a></h4>
<p><code>--dest-dir</code> (<code>-d</code>) 选项，允许您改变您的图书输出路径。注意如果是相对路径，则相对的是图书的根目录。如果没有指定 <code>--dest-dir</code> (<code>-d</code>)，则 <code>--dest-dir</code> (<code>-d</code>)的路径是在<code>book.toml</code>指定的，一般是 <code>./book</code></p>
<h4 id="specify-exclude-patterns-指定排除模式"><a class="header" href="#specify-exclude-patterns-指定排除模式">Specify exclude patterns 指定排除模式</a></h4>
<p><code>watch</code>命令不会自动触发
书籍根目录中<code>.gitignore</code>文件中包含的文件。<code>.gitignore</code>文件可以参考 <a href="https://git-scm.com/docs/gitignore">gitignore
documentation</a>.。这对于
忽略某些编辑者创建的临时文件是有帮助的。</p>
<p>注意：只有在图书根目录的<code>.gitignore</code>是有效的。全局变量指定的<code>$HOME/.gitignore</code> 或者上一级目录的<code>.gitignore</code>文件都是无效的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-serve-command"><a class="header" href="#the-serve-command">The serve command</a></h1>
<p>serve 命令可以在本地建立一个web服务器 通过 <code>localhost:3000</code>访问预览你的图书</p>
<pre><code class="language-bash">mdbook serve
</code></pre>
<p><code>serve</code>命令将监控书籍<code>src</code>目录
内容的更改，随时重建书籍并为每个更改刷新客户端;这包括
重新创建<code>SUMMARY.md</code>中仍然提到的已删除文件！并通过 websocket
连接用于触发客户端刷新。</p>
<p><em><strong>注意:</strong></em>   <code>serve</code>命令用于测试书籍的 HTML 输出，而不是
旨在成为网站的完整HTTP服务器。</p>
<h4 id="指定目录-3"><a class="header" href="#指定目录-3">指定目录</a></h4>
<p><code>serve</code>命令可以指定目录作为参数用作书籍
根目录而不是当前工作目录。</p>
<pre><code class="language-bash">mdbook serve path/to/book
</code></pre>
<h3 id="server-options"><a class="header" href="#server-options">Server options</a></h3>
<p><code>serve</code>主机名默认为“localhost”，端口默认为“3000”。可以在命令行上指定任一选项：</p>
<pre><code class="language-bash">mdbook serve path/to/book -p 8000 -n 127.0.0.1 
</code></pre>
<h4 id="--open-2"><a class="header" href="#--open-2">--open</a></h4>
<p>当您使用<code>--open</code>（<code>-o</code>）选项时，mdbook将在重构后，打开
您的默认网络浏览器。</p>
<h4 id="--dest-dir-2"><a class="header" href="#--dest-dir-2">--dest-dir</a></h4>
<p><code>--dest-dir</code> (<code>-d</code>) 选项，允许您改变您的图书输出路径。注意如果是相对路径，则相对的是图书的根目录。如果没有指定 <code>--dest-dir</code> (<code>-d</code>)，则 <code>--dest-dir</code> (<code>-d</code>)的路径是在<code>book.toml</code>指定的，一般是 <code>./book</code></p>
<h4 id="specify-exclude-patterns"><a class="header" href="#specify-exclude-patterns">Specify exclude patterns</a></h4>
<p><code>serve</code>命令不会自动触发
书籍根目录中<code>.gitignore</code>文件中包含的文件。<code>.gitignore</code>文件可以参考 <a href="https://git-scm.com/docs/gitignore">gitignore
documentation</a>.。这对于
忽略某些编辑者创建的临时文件是有帮助的。</p>
<p>注意：只有在图书根目录的<code>.gitignore</code>是有效的。全局变量指定的<code>$HOME/.gitignore</code> 或者上一级目录的<code>.gitignore</code>文件都是无效的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-test-command"><a class="header" href="#the-test-command">The test command</a></h1>
<p>在写一本书时，你有时需要自动化一些测试。例如
<a href="https://doc.rust-lang.org/stable/book/">Rust Programming Book</a>有很多
可能会过时的代码示例。因此，自动测试这些代码示例也是非常重要的。</p>
<p>mdBook 支持<code>test</code>命令，该命令将运行书籍中的所有可用测试。注意在
目前，仅支持 rustdoc 测试，但未来可能会支持的更多。</p>
<h4 id="禁止对代码块进行测试"><a class="header" href="#禁止对代码块进行测试">禁止对代码块进行测试</a></h4>
<p>rustdoc 不会测试包含 <code>ignore</code> 属性的代码块：</p>
<pre><code>```rust,ignore
fn main() {}
```
</code></pre>
<p>rustdoc 也不会测试指定 Rust 以外语言的代码块：</p>
<pre><code>```markdown
**Foo**: _bar_
```
</code></pre>
<p>rustdoc 也不会测试未指定语言的代码块：</p>
<pre><code>```
This is going to cause an error!
```
</code></pre>
<h4 id="指定目录-4"><a class="header" href="#指定目录-4">指定目录</a></h4>
<p><code>test</code>命令可以指定目录作为参数用作书籍
根目录而不是当前工作目录。</p>
<pre><code class="language-bash">mdbook test path/to/book
</code></pre>
<h4 id="--library-path"><a class="header" href="#--library-path">--library-path</a></h4>
<p><code>--library-path</code> (<code>-L</code>)  选项允许指定目录用于
<code>rustdoc</code>在构建和测试示例时使用的库搜索路径。添加多个
目录可以使用多个选项（(<code>-L foo -L bar</code>）或
逗号分隔列表 （-L foo,bar）。路径应指向Cargo
<a href="https://doc.rust-lang.org/cargo/guide/build-cache.html">build cache</a>  <code>deps</code> 目录</p>
<p>包含项目的生成输出。例如，如果你的 Rust 项目的书在目录中
名为“my-book”，以下命令将在运行“test”时包含 crate的依赖项：</p>
<pre><code class="language-shell">mdbook test my-book -L target/debug/deps/
</code></pre>
<p>获取更多信息，可以参考 <code>rustdoc</code>  命令行 <a href="https://doc.rust-lang.org/rustdoc/command-line-arguments.html#-l--library-path-where-to-look-for-dependencies">documentation</a></p>
<h4 id="--dest-dir-3"><a class="header" href="#--dest-dir-3">--dest-dir</a></h4>
<p><code>--dest-dir</code> (<code>-d</code>) 选项，允许您改变您的图书输出路径。注意如果是相对路径，则相对的是图书的根目录。如果没有指定 <code>--dest-dir</code> (<code>-d</code>)，则 <code>--dest-dir</code> (<code>-d</code>)的路径是在<code>book.toml</code>指定的，一般是 <code>./book</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-clean-command"><a class="header" href="#the-clean-command">The clean command</a></h1>
<p>clean 命令用于清除生成的书籍和任何其他构建效果。</p>
<pre><code class="language-bash">mdbook clean
</code></pre>
<h4 id="指定目录-5"><a class="header" href="#指定目录-5">指定目录</a></h4>
<p><code>clean</code>命令可以指定目录作为参数用作书籍
根目录而不是当前工作目录。</p>
<pre><code class="language-bash">mdbook clean path/to/book
</code></pre>
<h4 id="--dest-dir-4"><a class="header" href="#--dest-dir-4">--dest-dir</a></h4>
<p><code>--dest-dir</code> (<code>-d</code>) 选项，允许您改变您的图书输出路径。注意如果是相对路径，则相对的是图书的根目录。如果没有指定 <code>--dest-dir</code> (<code>-d</code>)，则 <code>--dest-dir</code> (<code>-d</code>)的路径是在<code>book.toml</code>指定的，一般是 <code>./book</code></p>
<pre><code class="language-bash">mdbook clean --dest-dir=path/to/book
</code></pre>
<p><code>path/to/book</code>  可以是相对路径也可以是绝对路径</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-completions-command"><a class="header" href="#the-completions-command">The completions command</a></h1>
<p>completions 命令用于为某些常见 shell 生成自动完成。这意味着当您在 shell 中键入 <code>mdbook</code> 时，您可以按 shell 的自动完成键（通常是 Tab 键），它可能会显示有效选项是什么，或者完成部分输入。</p>
<p>首先需要为您的 shell 安装完成：</p>
<pre><code class="language-bash">mdbook completions bash &gt; ~/.local/share/bash-completion/completions/mdbook
</code></pre>
<p>这个命令会告诉指定shell可以自动补全的脚本</p>
<p>运行 <code>mdbook completions --help</code> 以获取支持的shell列表。</p>
<p>将自动补全项放置在何处取决于您使用的 shell 和操作系统。
请参阅 shell 的文档，了解在何处放置脚本的详细信息。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="format"><a class="header" href="#format">Format</a></h1>
<p>在本节中，您将学习如何：:</p>
<ul>
<li>正确构建图书</li>
<li>格式化<code>SUMMARY.md</code>文件</li>
<li>使用<code>book.toml</code>配置您的图书</li>
<li>自定义您的主题</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summarymd--摘要文件"><a class="header" href="#summarymd--摘要文件">SUMMARY.md  摘要文件</a></h1>
<p>mdBook 使用摘要文件来了解要包含的章节、它们应以何种顺序显示、其层次结构是什么以及源文件的位置。没有这个<code>summary.md</code>摘要文件，就没有书。</p>
<p>这个命名为<code>SUMMARY.md</code> 格式为markdown的文件。其格式有要求
非常严格，必须遵循下面概述的结构，以便
解析。未指定的任何元素，无论是格式还是文本，都可能
被忽略，或者在尝试构建书籍时可能导致错误。</p>
<h3 id="structure-结构"><a class="header" href="#structure-结构">Structure 结构</a></h3>
<ol>
<li>
<p><em><strong>Title</strong></em> - 虽然是可选的，但通常的做法是从标题开始，通常是<code
class="language-markdown"># Summary</code>. 但是，解析器会忽略这一点，并且
可以省略。</p>
<pre><code class="language-markdown"># Summary
</code></pre>
</li>
<li>
<p><em><strong>Prefix Chapter</strong></em> - 前缀章节。在主要编号章节之前，可以添加前缀章节，这些是不会被编号。这对前言、简介等很有用。当然也存在一些制约因素。前缀章节不能是
嵌套;它们都应该在根级别上。并且您无法在
添加编号章节后添加前缀章节。</p>
<pre><code class="language-markdown">[A Prefix Chapter](relative/path/to/markdown.md)

- [First Chapter](relative/path/to/markdown2.md)
</code></pre>
</li>
<li>
<p><em><strong>Part Title</strong></em> - 分割标题。Headers can be used as a title for the following numbered
chapters. This can be used to logically separate different sections
of the book. The title is rendered as unclickable text.
Titles are optional, and the numbered chapters can be broken into as many
parts as desired.在一组编号的章节上面可以添加标题作为逻辑分割标题。标题呈现为不可点击的文本。
标题是可选的，编号的章节可以分成尽可能多的章节。</p>
<pre><code class="language-markdown"># My Part Title

- [First Chapter](relative/path/to/markdown.md)
</code></pre>
</li>
<li>
<p><em><strong>Numbered Chapter</strong></em> - 编号章节概述了本书的主要内容
并且可以嵌套，从而产生一个很好的层次结构
（章节、子章节等）。</p>
<pre><code class="language-markdown"># Title of Part

- [First Chapter](relative/path/to/markdown.md)
- [Second Chapter](relative/path/to/markdown2.md)
   - [Sub Chapter](relative/path/to/markdown3.md)

# Title of Another Part

- [Another Chapter](relative/path/to/markdown4.md)
</code></pre>
<p>编号的章节可以用<code>-</code>或<code>*</code>表示（不要混合分隔符）。</p>
</li>
<li>
<p><em><strong>Suffix Chapter</strong></em> - 后缀章节.与前缀章节一样，后缀章节未编号，但它们位于后面
编号的章节。</p>
<pre><code class="language-markdown">- [Last Chapter](relative/path/to/markdown.md)

[Title of Suffix Chapter](relative/path/to/markdown2.md)
</code></pre>
</li>
<li>
<p><em><strong>Draft chapters</strong></em> - 草稿章节是没有文件，因此没有内容的章节。
章节草案的目的是表明未来的章节仍有待编写。
或者，当仍然布置书籍的结构以避免创建文件时
而你仍然在改变这本书的结构。
草稿章节将在 HTML 呈现器中呈现为表格中的禁用链接
的内容，如您在左侧目录中的下一章中看到的那样。
草稿章节的编写方式与普通章节类似，但未写入文件的路径。</p>
<pre><code class="language-markdown">- [Draft Chapter]()
</code></pre>
</li>
<li>
<p><em><strong>Separators</strong></em> - 可以在任何其他元素之前、之间和之后添加分隔符。他们的结果
在构建的目录中的 HTML 呈现行中。 分隔符是
一行仅包含破折号和至少三个破折号：<code>---</code>。</p>
<pre><code class="language-markdown"># My Part Title

[A Prefix Chapter](relative/path/to/markdown.md)

---

- [First Chapter](relative/path/to/markdown2.md)
</code></pre>
</li>
</ol>
<h3 id="example-例子"><a class="header" href="#example-例子">Example 例子</a></h3>
<p>以下是本指南的<code>SUMMARY.md</code>的markdown 源码，左侧的栏位显示的内容就是设置的结果。</p>
<pre><code class="language-markdown"># Summary

[简介](README.md)

# 使用指南

- [安装](guide/installation.md)
- [阅读mdBook生成的图书](guide/reading.md)
- [通过mdBook制作图书](guide/creating.md)

# 参考指南

- [命令行工具](cli/README.md)
    - [init](cli/init.md)
    - [build](cli/build.md)
    - [watch](cli/watch.md)
    - [serve](cli/serve.md)
    - [test](cli/test.md)
    - [clean](cli/clean.md)
    - [completions](cli/completions.md)
- [Format](format/README.md)
    - [SUMMARY.md](format/summary.md)
        - [Draft chapter]()
    - [配置](format/configuration/README.md)
        - [General](format/configuration/general.md)
        - [Preprocessors](format/configuration/preprocessors.md)
        - [Renderers](format/configuration/renderers.md)
        - [Environment Variables](format/configuration/environment-variables.md)
    - [Theme](format/theme/README.md)
        - [index.hbs](format/theme/index-hbs.md)
        - [Syntax highlighting](format/theme/syntax-highlighting.md)
        - [Editor](format/theme/editor.md)
    - [MathJax Support](format/mathjax.md)
    - [mdBook-specific features](format/mdbook.md)
    - [Markdown](format/markdown.md)
- [持续集成](continuous-integration.md)
- [For Developers](for_developers/README.md)
    - [Preprocessors](for_developers/preprocessors.md)
    - [Alternative Backends](for_developers/backends.md)

-----------

[Contributors](misc/contributors.md)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="配置"><a class="header" href="#配置">配置</a></h1>
<p>本节详细介绍了 <em><strong>book.toml</strong></em> 中可用的配置选项：</p>
<ul>
<li><strong><a href="format/configuration/general.html">General</a></strong> 配置包括<code>书</code>，<code>rust</code>，<code>build</code>部分</li>
<li><strong><a href="format/configuration/preprocessors.html">Preprocessor</a></strong> 默认和自定义书籍预处理器的配置</li>
<li><strong><a href="format/configuration/renderers.html">Renderer</a></strong> HTML、Markdown 和自定义渲染器的配置</li>
<li><strong><a href="format/configuration/environment-variables.html">Environment Variable</a></strong> 用于覆盖环境中的配置选项的配置</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="general-configuration"><a class="header" href="#general-configuration">General Configuration</a></h1>
<p>您可以在 <em><strong>book.toml</strong></em> 文件中配置图书的参数。</p>
<p>下面是一个示例，说明 <em><strong>book.toml</strong></em> 文件：</p>
<pre><code class="language-toml">[book]
title = &quot;Example book&quot;
author = &quot;John Doe&quot;
description = &quot;The example book covers examples.&quot;

[rust]
edition = &quot;2018&quot;

[build]
build-dir = &quot;my-example-book&quot;
create-missing = false

[preprocessor.index]

[preprocessor.links]

[output.html]
additional-css = [&quot;custom.css&quot;]

[output.html.search]
limit-results = 15
</code></pre>
<h2 id="支持的配置选项"><a class="header" href="#支持的配置选项">支持的配置选项</a></h2>
<p>请务必注意，在
配置中的路径始终相对于书的根的位置，即配置文件的
位置。</p>
<h3 id="常规元数据"><a class="header" href="#常规元数据">常规元数据</a></h3>
<p>下面是图书的通常信息.</p>
<ul>
<li><strong>title:</strong> 书名</li>
<li><strong>authors:</strong> 本书的作者</li>
<li><strong>description:</strong> 该书的说明，作为元数据添加
每个页面的 html的 <code>&lt;head&gt;</code>中</li>
<li><strong>src:</strong> 默认情况下，源目录位于
根目录的<code>src</code>目录。但这可以通过<code>src</code> 元数据进行设置。</li>
<li><strong>language:</strong> 本书的主要语言，例如用作语言属性<code>&lt;html lang=&quot;en&quot;&gt;</code>。</li>
</ul>
<p><strong>book.toml</strong></p>
<pre><code class="language-toml">[book]
title = &quot;Example book&quot;
authors = [&quot;John Doe&quot;, &quot;Jane Doe&quot;]
description = &quot;The example book covers examples.&quot;
src = &quot;my-src&quot;  #源文件将放在“root/my-src”中，而不是“root/src”
language = &quot;en&quot;
</code></pre>
<h3 id="rust-options-rust-选项"><a class="header" href="#rust-options-rust-选项">Rust options Rust 选项</a></h3>
<p>Options for the Rust language, relevant to running tests and playground
integration.</p>
<p>Rust 语言的选项，与运行测试和 Playground 集成
有关。</p>
<pre><code class="language-toml">[rust]
edition = &quot;2015&quot;   # the default edition for code blocks
</code></pre>
<ul>
<li>
<p><strong>edition</strong>: 定义Rust 代码片段的默认版本。默认
是“2015”。单个代码块可以使用注释 如<code>edition2015</code>、
<code>edition2018</code>或<code>edition2021</code>进行设置，例如：</p>
<pre><code class="language-text">```rust,edition2015
// This only works in 2015.
let try = true;
```
</code></pre>
</li>
</ul>
<h3 id="build-options-构建选项"><a class="header" href="#build-options-构建选项">Build options 构建选项</a></h3>
<p>控制图书的构建过程选项。</p>
<pre><code class="language-toml">[build]
build-dir = &quot;book&quot;                # 设置输出的目录
create-missing = true             # 是否创建缺失页面
use-default-preprocessors = true  # 使用默认预处理器
</code></pre>
<ul>
<li>
<p><strong>build-dir:</strong> 用于放置渲染的书籍的目录。默认情况下，这是
<code>book/</code>在书籍的根目录中。
这可以用<code>--dest-dir</code> CLI 选项覆盖。</p>
</li>
<li>
<p><strong>create-missing:</strong> 默认情况下，在<code>SUMMARY.md</code>中指定的不存在的文件
将在本书构建时创建（即<code>create-missing = true</code>）。如果
为<code>false</code>，则当任何一个文件不存在的时候，构建过程将退出并显示错误。</p>
</li>
<li>
<p><strong>use-default-preprocessors:</strong> 禁用 默认预处理器（<code>links</code> &amp;
<code>索引</code>），通过将此选项设置为 <code>false</code>。</p>
<p>如果您有相同的和/或其他预处理器通过其表声明
的配置，它们将改为运行。</p>
<ul>
<li>为清楚起见，在没有定义预处理器配置的情况下，将采用默认的<code>links</code> and
<code>index</code> 。</li>
<li>设置<code>use-default-preprocessors = false</code>  则禁止默认的预处理器运行.</li>
<li>如果添加<code>[preprocessor.links]</code>，那么无论是否设置
<code>use-default-preprocessors</code> ，它将<code>links</code> 它将运行。</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuring-preprocessors-配置预处理器"><a class="header" href="#configuring-preprocessors-配置预处理器">Configuring Preprocessors 配置预处理器</a></h1>
<p>Preprocessors are extensions that can modify the raw Markdown source before it gets sent to the renderer.</p>
<p>预处理器是在将原始 Markdown 源发送到渲染器之前对其进行修改的扩展。</p>
<p>The following preprocessors are built-in and included by default:</p>
<p>默认情况下，以下预处理器是内置的：</p>
<ul>
<li><code>links</code>: Expands the <code>{{ #playground }}</code>, <code>{{ #include }}</code>, and <code>{{ #rustdoc_include }}</code> handlebars
helpers in a chapter to include the contents of a file.
See <a href="format/configuration/../mdbook.html#including-files">Including files</a> for more.</li>
<li>扩展 <code>{{ #playground }}</code>、<code>{{ #include }}</code>和<code>{{ #rustdoc_include }}</code>章节中的帮助程序，用于包含文件的内容。
有关详细信息，请参阅<a href="format/configuration/../mdbook.html#including-files">Including files</a>。</li>
<li><code>index</code>: Convert all chapter files named <code>README.md</code> into <code>index.md</code>. That is
to say, all <code>README.md</code> would be rendered to an index file <code>index.html</code> in the
rendered book.</li>
<li>将所有名为<code>README.md</code>的章节文件转换为<code>index.md</code>。也就是说，书中所有<code>README.md</code>都将渲染成索引文件<code>index.html</code>。</li>
</ul>
<p>The built-in preprocessors can be disabled with the <a href="format/configuration/general.html#build-options"><code>build.use-default-preprocessors</code></a> config option.</p>
<p>可以使用 <a href="format/configuration/general.html#build-options"><code>build.use-default-preprocessors</code></a> 配置选项禁用内置预处理器。</p>
<p>The community has developed several preprocessors.
See the <a href="https://github.com/rust-lang/mdBook/wiki/Third-party-plugins">Third Party Plugins</a> wiki page for a list of available preprocessors.</p>
<p>社区已经开发了几个预处理器。
请参阅<a href="https://github.com/rust-lang/mdBook/wiki/Third-party-plugins">Third Party Plugins</a> wiki 页面，了解可用的预处理器列表。</p>
<p>For information on how to create a new preprocessor, see the <a href="format/configuration/../../for_developers/preprocessors.html">Preprocessors for Developers</a> chapter.</p>
<p>有关如何创建新的预处理器的信息，请参阅<a href="format/configuration/../../for_developers/preprocessors.html">Preprocessors for Developers</a> 一章。</p>
<h2 id="custom-preprocessor-configuration-自定义预处理器配置"><a class="header" href="#custom-preprocessor-configuration-自定义预处理器配置">Custom Preprocessor Configuration 自定义预处理器配置</a></h2>
<p>Preprocessors can be added by including a <code>preprocessor</code> table in <code>book.toml</code> with the name of the preprocessor.
For example, if you have a preprocessor called <code>mdbook-example</code>, then you can include it with:</p>
<p>可以通过在<code>book.toml</code>中包含带有预处理器名称的<code>preprocessor</code> 表来添加预处理器。
例如，如果您有一个名为<code>mdbook-example</code>的预处理器，则可以将其包含在以下位置：</p>
<pre><code class="language-toml">[preprocessor.example]
</code></pre>
<p>With this table, mdBook will execute the <code>mdbook-example</code> preprocessor.</p>
<p>有了这个表，mdBook将执行<code>mdbook-example</code> 预处理器。</p>
<p>This table can include additional key-value pairs that are specific to the preprocessor.
For example, if our example preprocessor needed some extra configuration options:</p>
<p>此表可以包含特定于预处理器的其他键值对。
例如，如果我们的示例 preprocessor 需要一些额外的配置选项：</p>
<pre><code class="language-toml">[preprocessor.example]
some-extra-feature = true
</code></pre>
<h2 id="locking-a-preprocessor-dependency-to-a-renderer将预处理器依赖项锁定到呈现器"><a class="header" href="#locking-a-preprocessor-dependency-to-a-renderer将预处理器依赖项锁定到呈现器">Locking a Preprocessor dependency to a renderer将预处理器依赖项锁定到呈现器</a></h2>
<p>You can explicitly specify that a preprocessor should run for a renderer by
binding the two together.</p>
<p>您可以通过以下方式显式指定预处理器应为呈现器运行
将两者绑定在一起。</p>
<pre><code class="language-toml">[preprocessor.example]
renderers = [&quot;html&quot;]  # 示例预处理器仅使用 HTML 呈现器运行
</code></pre>
<h2 id="provide-your-own-command-提供您自己的命令"><a class="header" href="#provide-your-own-command-提供您自己的命令">Provide Your Own Command 提供您自己的命令</a></h2>
<p>By default when you add a <code>[preprocessor.foo]</code> table to your <code>book.toml</code> file,
<code>mdbook</code> will try to invoke the <code>mdbook-foo</code> executable. If you want to use a
different program name or pass in command-line arguments, this behaviour can
be overridden by adding a <code>command</code> field.</p>
<p>默认情况下，当您将<code>[preprocessor.foo]</code> 表添加到<code>book.toml</code>文件时，
<code>mdbook</code>将尝试调用<code>mdbook-foo</code> 可执行文件。如果要使用
不同的程序名称或传入命令行参数，此行为可以
通过添加 <code>command</code>字段进行覆盖。</p>
<pre><code class="language-toml">[preprocessor.random]
command = &quot;python random.py&quot;
</code></pre>
<h2 id="require-a-certain-order-需要一定的顺序"><a class="header" href="#require-a-certain-order-需要一定的顺序">Require A Certain Order 需要一定的顺序</a></h2>
<p>The order in which preprocessors are run can be controlled with the <code>before</code> and <code>after</code> fields.
For example, suppose you want your <code>linenos</code> preprocessor to process lines that may have been <code>{{#include}}</code>d; then you want it to run after the built-in <code>links</code> preprocessor, which you can require using either the <code>before</code> or <code>after</code> field:</p>
<p>预处理器的运行顺序可以通过<code>before</code> 和<code>after</code> 字段进行控制。
例如，假设您希望<code>linenos</code>预处理器处理可能是<code>{{#include}}</code>的行;然后，您希望它在内置的“链接”预处理器之后运行，您可以要求使用 <code>before</code>或<code>after</code>字段：</p>
<pre><code class="language-toml">[preprocessor.linenos]
after = [ &quot;links&quot; ]
</code></pre>
<p>or</p>
<pre><code class="language-toml">[preprocessor.links]
before = [ &quot;linenos&quot; ]
</code></pre>
<p>It would also be possible, though redundant, to specify both of the above in the same config file.</p>
<p>尽管是多余的，但也可以在同一配置文件中指定上述两者。</p>
<p>Preprocessors having the same priority specified through <code>before</code> and <code>after</code> are sorted by name.
Any infinite loops will be detected and produce an error.</p>
<p>通过<code>before</code> 和 <code>after</code>指定了相同优先级的预处理器按名称排序。
将检测到任何无限循环并产生错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuring-renderers-配置渲染器"><a class="header" href="#configuring-renderers-配置渲染器">Configuring Renderers 配置渲染器</a></h1>
<p>渲染器（也称为“后端”）负责创建书籍的输出。</p>
<p>以下是内置的后端：</p>
<ul>
<li><a href="format/configuration/renderers.html#html-renderer-options"><code>html</code></a> — 这会将书籍呈现为 HTML。
如果<code>book.toml</code>中未定义其他<code>[output]</code> 表，则默认启用此功能。</li>
<li><a href="format/configuration/renderers.html#markdown-renderer"><code>markdown</code></a> —这将在运行预处理器后将书籍输出为markdown。
这对于调试预处理器非常有用。</li>
</ul>
<p>社区已经开发了几个后端。
请参阅 <a href="https://github.com/rust-lang/mdBook/wiki/Third-party-plugins">Third Party Plugins</a> wiki页面以获取可用后端的列表。</p>
<p>有关如何创建新的后端的信息，请参阅 <a href="format/configuration/../../for_developers/backends.html">Backends for Developers</a> 一章。</p>
<h2 id="output-tables"><a class="header" href="#output-tables">Output tables</a></h2>
<p>可以通过在 <code>book.toml</code>中包含带有后端名称的<code>output</code>表来添加后端。
例如，如果你有一个名为<code>mdbook-wordcount</code>的后端，那么你可以用：</p>
<pre><code class="language-toml">[output.wordcount]
</code></pre>
<p>有了这个表，mdBook将执行<code>mdbook-wordcount</code>后端。</p>
<p>此表可以包含特定于后端的其他键值对。
例如，如果我们的示例后端需要一些额外的配置选项：</p>
<pre><code class="language-toml">[output.wordcount]
ignores = [&quot;Example Chapter&quot;]
</code></pre>
<p>如果定义任何 <code>[output]</code>表，则默认情况下不启用<code>html</code>后端。
如果你想保持<code>html</code>后端运行，那么只需将其包含在<code>book.toml</code>文件中。
例如：</p>
<pre><code class="language-toml">[book]
title = &quot;My Awesome Book&quot;
[output.wordcount]
[output.html]
</code></pre>
<p>如果包含多个<code>输出</code>表，则会更改输出目录布局的行为。
如果只有一个后端，则将其输出直接放在<code>book</code>目录中（请参阅<a href="format/configuration/general.html#build-options"><code>build.build-dir</code></a>以覆盖此位置）。
如果有多个后端，则每个后端都放在<code>book</code>下的单独目录中。
例如，上面将有目录<code>book/html</code>和<code>book/wordcount</code>。</p>
<h3 id="custom-backend-commands-自定义后端命令"><a class="header" href="#custom-backend-commands-自定义后端命令">Custom backend commands 自定义后端命令</a></h3>
<p>默认情况下，当您将 <code>[output.foo]</code> 表添加到<code>book.toml</code>文件时，
<code>mdbook</code>将尝试调用<code>mdbook-foo</code>可执行文件。
如果要使用其他程序名称或传入命令行参数，
可以通过添加<code>command</code>字段来覆盖此行为。</p>
<pre><code class="language-toml">[output.random]
command = &quot;python random.py&quot;
</code></pre>
<h3 id="optional-backends-可选后端"><a class="header" href="#optional-backends-可选后端">Optional backends 可选后端</a></h3>
<p>如果启用未安装的后端，则默认行为是引发错误。
可以通过将后端标记为可选来更改此行为：</p>
<pre><code class="language-toml">[output.wordcount]
optional = true
</code></pre>
<p>这会将错误降级为警告</p>
<h2 id="html-renderer-options-html-呈现器选项"><a class="header" href="#html-renderer-options-html-呈现器选项">HTML renderer options. HTML 呈现器选项</a></h2>
<p>HTML 呈现器具有下面详细介绍的各种选项。
它们应该在<code>book.toml</code>文件的<code>[output.html]</code>表中指定。</p>
<pre><code class="language-toml"># 包含所有输出选项的示例 book.toml 文件。
[book]
title = &quot;Example book&quot;
authors = [&quot;John Doe&quot;, &quot;Jane Doe&quot;]
description = &quot;The example book covers examples.&quot;
[output.html]
theme = &quot;my-theme&quot;
default-theme = &quot;light&quot;
preferred-dark-theme = &quot;navy&quot;
curly-quotes = true
mathjax-support = false
copy-fonts = true
additional-css = [&quot;custom.css&quot;, &quot;custom2.css&quot;]
additional-js = [&quot;custom.js&quot;]
no-section-label = false
git-repository-url = &quot;https://github.com/rust-lang/mdBook&quot;
git-repository-icon = &quot;fa-github&quot;
edit-url-template = &quot;https://github.com/rust-lang/mdBook/edit/master/guide/{path}&quot;
site-url = &quot;/example-book/&quot;
cname = &quot;myproject.rs&quot;
input-404 = &quot;not-found.md&quot;
</code></pre>
<p>以下可用配置选项:</p>
<ul>
<li><strong>theme:</strong> mdBook附带了默认主题和所需的所有资源文件
为它。但是，如果设置了此选项，mdBook将有选择地覆盖主题
文件，其中包含在指定文件夹中找到的文件。</li>
<li><strong>default-theme:</strong> 默认情况下要在
“更改主题”下拉列表。默认为“浅”。</li>
<li><strong>preferred-dark-theme:</strong> 默认的深色主题。在以下情况下将使用本主题：
浏览器通过
<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme">'prefers-color-scheme'</a>
CSS 媒体查询。默认为<code>navy</code>.</li>
<li><strong>curly-quotes:</strong>  <code>false</code>.将直引号转换为卷引号，但那些
出现在代码块和代码中。默认值为<code>false</code>。</li>
<li><strong>mathjax-support:</strong> 添加了对 <a href="format/configuration/../mathjax.html">MathJax</a> 支持。默认值为
<code>false</code>。</li>
<li><strong>copy-fonts:</strong> 将字体.css和相应的字体文件复制到输出目录，并在默认主题中使用它们。默认为<code>true</code>。</li>
<li><strong>google-analytics:</strong> 此字段已被弃用，并将在将来的版本中删除。
使用 <code>theme/head.hbs</code>文件来添加相应的Google Analytics（分析）代码。</li>
<li><strong>additional-css:</strong> 如果您需要稍微更改图书的外观
在不覆盖整个样式的情况下，您可以指定一组样式表，
将在默认的之后加载，您可以在其中更改
风格。</li>
<li><strong>additional-js:</strong> 如果您需要在书中添加一些行为，而无需
删除当前行为，您可以指定一组 JavaScript 文件
将与默认一起加载。</li>
<li><strong>no-section-label:</strong> 默认情况下，mdBook 会添加
内容列。例如，“1.”、“2.1”。将此选项设置为 true 可禁用
那些标签。默认值为<code>false</code>.</li>
<li><strong>git-repository-url:</strong>  书籍的 git 存储库的 url。如果提供
图标链接将输出到书籍的菜单栏中。</li>
<li><strong>git-repository-icon:</strong> 用于 git 的 FontAwesome 图标类
存储库链接。默认为<code>fa-github</code>，看起来像 <i class="fa fa-github"></i>.
如果你没有使用GitHub，另一个要考虑的选项是<code>fa-code-fork</code>，它看起来像<i class="fa fa-github"></i>.。</li>
<li><strong>edit-url-template:</strong> 编辑网址模板（如果提供）显示
“建议编辑”按钮（看起来像<i class="fa fa-edit"></i>）用于直接跳转到编辑当前
已查看页面。例如，对于 GitHub 项目，将其设置为
<code>https://github.com/&lt;owner&gt;/&lt;repo&gt;/edit/master/{path}</code>或 for
Bitbucket 项目将其设置为
<code>https://bitbucket.org/&lt;owner&gt;/&lt;repo&gt;/src/master/{path}?mode=edit</code>
其中 {path} 将被替换为
存储 库。</li>
<li><strong>input-404:</strong> 用于不存在的 markdown 文件的名称。
相应的输出文件将相同，扩展名将替换为“html”。
默认值为<code>404.md</code>。</li>
<li><strong>site-url:</strong> 将托管图书的网址。这是确保
404 文件中的导航链接和脚本/css 导入可以正常工作，即使在访问
子目录中的网址。默认值为<code>/</code></li>
<li><strong>cname:</strong> 将托管图书的 DNS 子域或顶点域。
此字符串将写入站点根目录中名为 CNAME 的文件中，如下所示
GitHub Pages 所需的 (see <a href="https://docs.github.com/en/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site"><em>Managing a custom domain for your GitHub Pages
site</em></a>).</li>
</ul>
<h3 id="outputhtmlprint"><a class="header" href="#outputhtmlprint"><code>[output.html.print]</code></a></h3>
<p><code>[output.html.print]</code> 表提供了用于控制可打印输出的选项。
默认情况下，mdBook 将在书籍的右上角包含一个图标（看起来像 <i class="fa fa-print"></i>），该图标会将书籍打印为一页。</p>
<pre><code class="language-toml">[output.html.print]
enable = true    # include support for printable output
page-break = true # insert page-break after each chapter
</code></pre>
<ul>
<li><strong>enable:</strong> 启用打印支持。当<code>false</code>时，所有打印支持将不会
呈现。默认为<code>true</code>。</li>
<li><strong>page-break</strong> 在章节之间插入分页符。默认为<code>true</code>。</li>
</ul>
<h3 id="outputhtmlfold"><a class="header" href="#outputhtmlfold"><code>[output.html.fold]</code></a></h3>
<p>The <code>[output.html.fold]</code> 表提供了用于控制导航侧栏中章节列表折叠的选项。</p>
<pre><code class="language-toml">[output.html.fold]
enable = false    #是否启用截面折叠
level = 0         # 开始折叠的深度
</code></pre>
<ul>
<li><strong>enable:</strong> 启用截面折叠。关闭时，所有折叠都打开。
默认值为<code>false</code>。</li>
<li><strong>level:</strong> 折叠区域越高，打开的区域就越多。当级别为 0 时，全部
褶皱是闭合的。默认值为 <code>0</code>。</li>
</ul>
<h3 id="outputhtmlplayground"><a class="header" href="#outputhtmlplayground"><code>[output.html.playground]</code></a></h3>
<p><code>[output.html.playground]</code> 提供了用于控制 Rust 示例代码块及其与 <a href="https://play.rust-lang.org/">Rust Playground</a> 集成的选项。</p>
<pre><code class="language-toml">[output.html.playground]
editable = false         # 允许编辑源代码
copyable = true          # 包括用于复制代码片段的复制按钮
copy-js = true           # 包括代码编辑器的 JavaScript
line-numbers = false     # 显示可编辑代码的行号
runnable = true          # 显示Rust 代码的运行按钮
</code></pre>
<ul>
<li><strong>editable:</strong> 允许编辑源代码。默认值为 <code>false</code>.</li>
<li><strong>copyable:</strong> 在代码段上显示复制按钮。默认值为 <code>true</code>.</li>
<li><strong>copy-js:</strong> 将编辑器的 JavaScript 文件复制到输出目录。
默认值为 <code>true</code>.</li>
<li><strong>line-numbers</strong> 在可编辑的代码段上显示行号。要求<code>editable</code>和<code>copy-js</code>都是<code>true</code>。默认值为</li>
<li><strong>runnable</strong> 显示 Rust 代码段的运行按钮。将此更改为<code>false</code>将全局禁用在操场中运行功能。默认值为<code>true</code>.</li>
</ul>
<h3 id="outputhtmlsearch"><a class="header" href="#outputhtmlsearch"><code>[output.html.search]</code></a></h3>
<p><code>[output.html.search]</code> 表提供了用于控制内置文本 <a href="format/configuration/../../guide/reading.html#search">search</a>的选项。
mdBook 必须在启用<code>search</code>功能的情况下进行编译（默认情况下处于打开状态）。</p>
<pre><code class="language-toml">[output.html.search]
enable = true            # 启用搜索功能
limit-results = 30       # 最大搜索结果数
teaser-word-count = 30   # 用于搜索结果摘要的字数
use-boolean-and = true   # 多个搜索词必须全部匹配
boost-title = 2          # 标题中匹配项的排名提升因子
boost-hierarchy = 1      # 页面名称中匹配项的排名提升因素
boost-paragraph = 1      # 文本中匹配项的排名提升因素
expand = true            # 部分字词将与较长的字词匹配
heading-split-level = 3  # 将结果链接到标题级别
copy-js = true           # 包括用于搜索的 Javascript 代码
</code></pre>
<ul>
<li><strong>enable:</strong> 启用搜索功能。默认值为 <code>true</code>.</li>
<li><strong>limit-results:</strong> 搜索结果的最大数量。默认值为 <code>30</code>.</li>
<li><strong>teaser-word-count:</strong> 用于搜索结果摘要的字数。
默认值为 <code>30</code>.</li>
<li><strong>use-boolean-and:</strong> 定义多个搜索词之间的逻辑链接。如果
true，所有搜索词都必须出现在每个结果中。默认值为 <code>false</code>.</li>
<li><strong>boost-title:</strong> 如果搜索词，则搜索结果分数的提升因素
将显示在页眉中。默认值为 <code>2</code>.</li>
<li><strong>boost-hierarchy:</strong> 如果搜索词，则搜索结果分数的提升因素
将显示在层次结构中。层次结构包含父级的所有标题
文档和所有父标题。默认值为 <code>1</code>.</li>
<li><strong>boost-paragraph:</strong> 如果搜索词，则搜索结果分数的提升因素
将显示在文本中。默认值为 <code>1</code>.</li>
<li><strong>expand:</strong> 如果搜索应匹配较长的结果，例如搜索<code>micro</code>，则为 true
应该匹配<code>microwave</code>。默认为“true”。</li>
<li><strong>heading-split-level:</strong> 搜索结果将链接到文档的某个部分
其中包含结果。文档按标题分成几个部分
级别或更低。默认值为<code>3</code>. (<code>### This is a level 3 heading</code>)</li>
<li><strong>copy-js:</strong> 将搜索实现的 JavaScript 文件复制到输出
目录。默认值为 <code>true</code>.</li>
</ul>
<h3 id="outputhtmlredirect"><a class="header" href="#outputhtmlredirect"><code>[output.html.redirect]</code></a></h3>
<p><code>[output.html.redirect]</code> 表提供了一种添加重定向的方法。
当您移动、重命名或删除页面以确保指向旧 URL 的链接将转到新位置时，这很有用。</p>
<pre><code class="language-toml">[output.html.redirect]
&quot;/appendices/bibliography.html&quot; = &quot;https://rustc-dev-guide.rust-lang.org/appendix/bibliography.html&quot;
&quot;/other-installation-methods.html&quot; = &quot;../infra/other-installation-methods.html&quot;
</code></pre>
<p>该表包含键值对，其中键是需要创建重定向文件的位置，作为构建目录的绝对路径（例如<code>/appendices/bibliography.html</code>）。
该值可以是浏览器应导航到的任何有效 URI（例如，<code>https://rust-lang.org/</code>,<code>/overview.html</code>或<code>../bibliography.html</code>）。</p>
<p>这将生成一个HTML页面，该页面将自动重定向到给定位置。
请注意，源位置不支持<code>#</code> 锚点重定向。</p>
<h2 id="markdown-renderer"><a class="header" href="#markdown-renderer">Markdown Renderer</a></h2>
<p>Markdown 渲染器将运行预处理器，然后输出结果
Markdown。这对于调试预处理器非常有用，尤其是在
与<code>mdbook test</code>结合使用，以查看<code>mdbook</code>正在通过的Markdown
到<code>rustdoc</code>。</p>
<p>Markdown 渲染器包含在 <code>mdbook</code> 中，但默认情况下处于禁用状态。
通过向<code>book.toml</code>添加一个空表来启用它，如下所示：</p>
<pre><code class="language-toml">[output.markdown]
</code></pre>
<p>目前没有Markdown渲染器的配置选项。
仅启用还是禁用。</p>
<p>参考 <a href="format/configuration/preprocessors.html">the preprocessors documentation</a> 有关如何操作
指定哪些预处理器应在 Markdown 渲染器之前运行。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h1>
<p>All configuration values can be overridden from the command line by setting the
corresponding environment variable. Because many operating systems restrict
environment variables to be alphanumeric characters or <code>_</code>, the configuration
key needs to be formatted slightly differently to the normal <code>foo.bar.baz</code> form.</p>
<p>Variables starting with <code>MDBOOK_</code> are used for configuration. The key is created
by removing the <code>MDBOOK_</code> prefix and turning the resulting string into
<code>kebab-case</code>. Double underscores (<code>__</code>) separate nested keys, while a single
underscore (<code>_</code>) is replaced with a dash (<code>-</code>).</p>
<p>For example:</p>
<ul>
<li><code>MDBOOK_foo</code> -&gt; <code>foo</code></li>
<li><code>MDBOOK_FOO</code> -&gt; <code>foo</code></li>
<li><code>MDBOOK_FOO__BAR</code> -&gt; <code>foo.bar</code></li>
<li><code>MDBOOK_FOO_BAR</code> -&gt; <code>foo-bar</code></li>
<li><code>MDBOOK_FOO_bar__baz</code> -&gt; <code>foo-bar.baz</code></li>
</ul>
<p>So by setting the <code>MDBOOK_BOOK__TITLE</code> environment variable you can override the
book's title without needing to touch your <code>book.toml</code>.</p>
<blockquote>
<p><strong>Note:</strong> To facilitate setting more complex config items, the value of an
environment variable is first parsed as JSON, falling back to a string if the
parse fails.</p>
<p>This means, if you so desired, you could override all book metadata when
building the book with something like</p>
<pre><code class="language-shell">$ export MDBOOK_BOOK=&quot;{'title': 'My Awesome Book', authors: ['Michael-F-Bryan']}&quot;
$ mdbook build
</code></pre>
</blockquote>
<p>The latter case may be useful in situations where <code>mdbook</code> is invoked from a
script or CI, where it sometimes isn't possible to update the <code>book.toml</code> before
building.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="theme"><a class="header" href="#theme">Theme</a></h1>
<p>The default renderer uses a <a href="http://handlebarsjs.com/">handlebars</a> template to
render your markdown files and comes with a default theme included in the mdBook
binary.</p>
<p>The theme is totally customizable, you can selectively replace every file from
the theme by your own by adding a <code>theme</code> directory next to <code>src</code> folder in your
project root. Create a new file with the name of the file you want to override
and now that file will be used instead of the default file.</p>
<p>Here are the files you can override:</p>
<ul>
<li><strong><em>index.hbs</em></strong> is the handlebars template.</li>
<li><strong><em>head.hbs</em></strong> is appended to the HTML <code>&lt;head&gt;</code> section.</li>
<li><strong><em>header.hbs</em></strong> content is appended on top of every book page.</li>
<li><strong><em>css/</em></strong> contains the CSS files for styling the book.
<ul>
<li><strong><em>css/chrome.css</em></strong> is for UI elements.</li>
<li><strong><em>css/general.css</em></strong> is the base styles.</li>
<li><strong><em>css/print.css</em></strong> is the style for printer output.</li>
<li><strong><em>css/variables.css</em></strong> contains variables used in other CSS files.</li>
</ul>
</li>
<li><strong><em>book.js</em></strong> is mostly used to add client side functionality, like hiding /
un-hiding the sidebar, changing the theme, ...</li>
<li><strong><em>highlight.js</em></strong> is the JavaScript that is used to highlight code snippets,
you should not need to modify this.</li>
<li><strong><em>highlight.css</em></strong> is the theme used for the code highlighting.</li>
<li><strong><em>favicon.svg</em></strong> and <strong><em>favicon.png</em></strong> the favicon that will be used. The SVG
version is used by <a href="https://caniuse.com/#feat=link-icon-svg">newer browsers</a>.</li>
</ul>
<p>Generally, when you want to tweak the theme, you don't need to override all the
files. If you only need changes in the stylesheet, there is no point in
overriding all the other files. Because custom files take precedence over
built-in ones, they will not get updated with new fixes / features.</p>
<p><strong>Note:</strong> When you override a file, it is possible that you break some
functionality. Therefore I recommend to use the file from the default theme as
template and only add / modify what you need. You can copy the default theme
into your source directory automatically by using <code>mdbook init --theme</code> and just
remove the files you don't want to override.</p>
<p><code>mdbook init --theme</code> will not create every file listed above.
Some files, such as <code>head.hbs</code>, do not have built-in equivalents.
Just create the file if you need it.</p>
<p>If you completely replace all built-in themes, be sure to also set
<a href="format/theme/../configuration/renderers.html#html-renderer-options"><code>output.html.preferred-dark-theme</code></a> in the config, which defaults to the
built-in <code>navy</code> theme.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indexhbs"><a class="header" href="#indexhbs">index.hbs</a></h1>
<p><code>index.hbs</code> is the handlebars template that is used to render the book. The
markdown files are processed to html and then injected in that template.</p>
<p>If you want to change the layout or style of your book, chances are that you
will have to modify this template a little bit. Here is what you need to know.</p>
<h2 id="data"><a class="header" href="#data">Data</a></h2>
<p>A lot of data is exposed to the handlebars template with the &quot;context&quot;. In the
handlebars template you can access this information by using</p>
<pre><code class="language-handlebars">{{name_of_property}}
</code></pre>
<p>Here is a list of the properties that are exposed:</p>
<ul>
<li>
<p><em><strong>language</strong></em> Language of the book in the form <code>en</code>, as specified in <code>book.toml</code> (if not specified, defaults to <code>en</code>). To use in <code
class="language-html">&lt;html lang=&quot;{{ language }}&quot;&gt;</code> for example.</p>
</li>
<li>
<p><em><strong>title</strong></em> Title used for the current page. This is identical to <code>{{ chapter_title }} - {{ book_title }}</code> unless <code>book_title</code> is not set in which case it just defaults to the <code>chapter_title</code>.</p>
</li>
<li>
<p><em><strong>book_title</strong></em> Title of the book, as specified in <code>book.toml</code></p>
</li>
<li>
<p><em><strong>chapter_title</strong></em> Title of the current chapter, as listed in <code>SUMMARY.md</code></p>
</li>
<li>
<p><em><strong>path</strong></em> Relative path to the original markdown file from the source
directory</p>
</li>
<li>
<p><em><strong>content</strong></em> This is the rendered markdown.</p>
</li>
<li>
<p><em><strong>path_to_root</strong></em> This is a path containing exclusively <code>../</code>'s that points
to the root of the book from the current file. Since the original directory
structure is maintained, it is useful to prepend relative links with this
<code>path_to_root</code>.</p>
</li>
<li>
<p><em><strong>chapters</strong></em> Is an array of dictionaries of the form</p>
<pre><code class="language-json">{&quot;section&quot;: &quot;1.2.1&quot;, &quot;name&quot;: &quot;name of this chapter&quot;, &quot;path&quot;: &quot;dir/markdown.md&quot;}
</code></pre>
<p>containing all the chapters of the book. It is used for example to construct
the table of contents (sidebar).</p>
</li>
</ul>
<h2 id="handlebars-helpers"><a class="header" href="#handlebars-helpers">Handlebars Helpers</a></h2>
<p>In addition to the properties you can access, there are some handlebars helpers
at your disposal.</p>
<h3 id="1-toc"><a class="header" href="#1-toc">1. toc</a></h3>
<p>The toc helper is used like this</p>
<pre><code class="language-handlebars">{{#toc}}{{/toc}}
</code></pre>
<p>and outputs something that looks like this, depending on the structure of your
book</p>
<pre><code class="language-html">&lt;ul class=&quot;chapter&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;link/to/file.html&quot;&gt;Some chapter&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;
        &lt;ul class=&quot;section&quot;&gt;
            &lt;li&gt;&lt;a href=&quot;link/to/other_file.html&quot;&gt;Some other Chapter&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>If you would like to make a toc with another structure, you have access to the
chapters property containing all the data. The only limitation at the moment
is that you would have to do it with JavaScript instead of with a handlebars
helper.</p>
<pre><code class="language-html">&lt;script&gt;
var chapters = {{chapters}};
// Processing here
&lt;/script&gt;
</code></pre>
<h3 id="2-previous--next"><a class="header" href="#2-previous--next">2. previous / next</a></h3>
<p>The previous and next helpers expose a <code>link</code> and <code>name</code> property to the
previous and next chapters.</p>
<p>They are used like this</p>
<pre><code class="language-handlebars">{{#previous}}
    &lt;a href=&quot;{{link}}&quot; class=&quot;nav-chapters previous&quot;&gt;
        &lt;i class=&quot;fa fa-angle-left&quot;&gt;&lt;/i&gt;
    &lt;/a&gt;
{{/previous}}
</code></pre>
<p>The inner html will only be rendered if the previous / next chapter exists.
Of course the inner html can be changed to your liking.</p>
<hr />
<p><em>If you would like other properties or helpers exposed, please <a href="https://github.com/rust-lang/mdBook/issues">create a new
issue</a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="syntax-highlighting"><a class="header" href="#syntax-highlighting">Syntax Highlighting</a></h1>
<p>mdBook uses <a href="https://highlightjs.org">Highlight.js</a> with a custom theme
for syntax highlighting.</p>
<p>Automatic language detection has been turned off, so you will probably want to
specify the programming language you use like this:</p>
<pre><code class="language-markdown">```rust
fn main() {
    // Some code
}
```
</code></pre>
<h2 id="supported-languages"><a class="header" href="#supported-languages">Supported languages</a></h2>
<p>These languages are supported by default, but you can add more by supplying
your own <code>highlight.js</code> file:</p>
<ul>
<li>apache</li>
<li>armasm</li>
<li>bash</li>
<li>c</li>
<li>coffeescript</li>
<li>cpp</li>
<li>csharp</li>
<li>css</li>
<li>d</li>
<li>diff</li>
<li>go</li>
<li>handlebars</li>
<li>haskell</li>
<li>http</li>
<li>ini</li>
<li>java</li>
<li>javascript</li>
<li>json</li>
<li>julia</li>
<li>kotlin</li>
<li>less</li>
<li>lua</li>
<li>makefile</li>
<li>markdown</li>
<li>nginx</li>
<li>objectivec</li>
<li>perl</li>
<li>php</li>
<li>plaintext</li>
<li>properties</li>
<li>python</li>
<li>r</li>
<li>ruby</li>
<li>rust</li>
<li>scala</li>
<li>scss</li>
<li>shell</li>
<li>sql</li>
<li>swift</li>
<li>typescript</li>
<li>x86asm</li>
<li>xml</li>
<li>yaml</li>
</ul>
<h2 id="custom-theme"><a class="header" href="#custom-theme">Custom theme</a></h2>
<p>Like the rest of the theme, the files used for syntax highlighting can be
overridden with your own.</p>
<ul>
<li><em><strong>highlight.js</strong></em> normally you shouldn't have to overwrite this file, unless
you want to use a more recent version.</li>
<li><em><strong>highlight.css</strong></em> theme used by highlight.js for syntax highlighting.</li>
</ul>
<p>If you want to use another theme for <code>highlight.js</code> download it from their
website, or make it yourself, rename it to <code>highlight.css</code> and put it in
the <code>theme</code> folder of your book.</p>
<p>Now your theme will be used instead of the default theme.</p>
<h2 id="hiding-code-lines"><a class="header" href="#hiding-code-lines">Hiding code lines</a></h2>
<p>There is a feature in mdBook that lets you hide code lines by prepending them
with a <code>#</code>.</p>
<pre><code class="language-bash"># fn main() {
    let x = 5;
    let y = 6;

    println!(&quot;{}&quot;, x + y);
# }
</code></pre>
<p>Will render as</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">fn main() {
</span>    let x = 5;
    let y = 7;

    println!(&quot;{}&quot;, x + y);
<span class="boring">}
</span></code></pre></pre>
<p><strong>At the moment, this only works for code examples that are annotated with
<code>rust</code>. Because it would collide with semantics of some programming languages.
In the future, we want to make this configurable through the <code>book.toml</code> so that
everyone can benefit from it.</strong></p>
<h2 id="improve-default-theme"><a class="header" href="#improve-default-theme">Improve default theme</a></h2>
<p>If you think the default theme doesn't look quite right for a specific language,
or could be improved, feel free to <a href="https://github.com/rust-lang/mdBook/issues">submit a new
issue</a> explaining what you
have in mind and I will take a look at it.</p>
<p>You could also create a pull-request with the proposed improvements.</p>
<p>Overall the theme should be light and sober, without too many flashy colors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="editor"><a class="header" href="#editor">Editor</a></h1>
<p>In addition to providing runnable code playgrounds, mdBook optionally allows them
to be editable. In order to enable editable code blocks, the following needs to
be added to the <em><strong>book.toml</strong></em>:</p>
<pre><code class="language-toml">[output.html.playground]
editable = true
</code></pre>
<p>To make a specific block available for editing, the attribute <code>editable</code> needs
to be added to it:</p>
<pre><code class="language-markdown">```rust,editable
fn main() {
    let number = 5;
    print!(&quot;{}&quot;, number);
}
```
</code></pre>
<p>The above will result in this editable playground:</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    let number = 5;
    print!(&quot;{}&quot;, number);
}
</code></pre></pre>
<p>Note the new <code>Undo Changes</code> button in the editable playgrounds.</p>
<h2 id="customizing-the-editor"><a class="header" href="#customizing-the-editor">Customizing the Editor</a></h2>
<p>By default, the editor is the <a href="https://ace.c9.io/">Ace</a> editor, but, if desired,
the functionality may be overridden by providing a different folder:</p>
<pre><code class="language-toml">[output.html.playground]
editable = true
editor = &quot;/path/to/editor&quot;
</code></pre>
<p>Note that for the editor changes to function correctly, the <code>book.js</code> inside of
the <code>theme</code> folder will need to be overridden as it has some couplings with the
default Ace editor.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mathjax-support"><a class="header" href="#mathjax-support">MathJax Support</a></h1>
<p>mdBook has optional support for math equations through
<a href="https://www.mathjax.org/">MathJax</a>.</p>
<p>To enable MathJax, you need to add the <code>mathjax-support</code> key to your <code>book.toml</code>
under the <code>output.html</code> section.</p>
<pre><code class="language-toml">[output.html]
mathjax-support = true
</code></pre>
<blockquote>
<p><strong>Note:</strong> The usual delimiters MathJax uses are not yet supported. You can't
currently use <code>$$ ... $$</code> as delimiters and the <code>\[ ... \]</code> delimiters need an
extra backslash to work. Hopefully this limitation will be lifted soon.</p>
</blockquote>
<blockquote>
<p><strong>Note:</strong> When you use double backslashes in MathJax blocks (for example in
commands such as <code>\begin{cases} \frac 1 2 \\ \frac 3 4 \end{cases}</code>) you need
to add <em>two extra</em> backslashes (e.g., <code>\begin{cases} \frac 1 2 \\\\ \frac 3 4 \end{cases}</code>).</p>
</blockquote>
<h3 id="inline-equations"><a class="header" href="#inline-equations">Inline equations</a></h3>
<p>Inline equations are delimited by <code>\\(</code> and <code>\\)</code>. So for example, to render the
following inline equation \( \int x dx = \frac{x^2}{2} + C \) you would write
the following:</p>
<pre><code>\\( \int x dx = \frac{x^2}{2} + C \\)
</code></pre>
<h3 id="block-equations"><a class="header" href="#block-equations">Block equations</a></h3>
<p>Block equations are delimited by <code>\\[</code> and <code>\\]</code>. To render the following
equation</p>
<p>\[ \mu = \frac{1}{N} \sum_{i=0} x_i \]</p>
<p>you would write:</p>
<pre><code class="language-bash">\\[ \mu = \frac{1}{N} \sum_{i=0} x_i \\]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mdbook-specific-features"><a class="header" href="#mdbook-specific-features">mdBook-specific features</a></h1>
<h2 id="hiding-code-lines-1"><a class="header" href="#hiding-code-lines-1">Hiding code lines</a></h2>
<p>There is a feature in mdBook that lets you hide code lines by prepending them
with a <code>#</code> <a href="https://doc.rust-lang.org/stable/rustdoc/documentation-tests.html#hiding-portions-of-the-example">like you would with Rustdoc</a>.
This currently only works with Rust language code blocks.</p>
<pre><code class="language-bash"># fn main() {
    let x = 5;
    let y = 6;

    println!(&quot;{}&quot;, x + y);
# }
</code></pre>
<p>Will render as</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">fn main() {
</span>    let x = 5;
    let y = 6;

    println!(&quot;{}&quot;, x + y);
<span class="boring">}
</span></code></pre></pre>
<p>The code block has an eyeball icon (<i class="fa fa-eye"></i>) which will toggle the visibility of the hidden lines.</p>
<h2 id="rust-playground"><a class="header" href="#rust-playground">Rust Playground</a></h2>
<p>Rust language code blocks will automatically get a play button (<i class="fa fa-play"></i>) which will execute the code and display the output just below the code block.
This works by sending the code to the <a href="https://play.rust-lang.org/">Rust Playground</a>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;Hello, World!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>If there is no <code>main</code> function, then the code is automatically wrapped inside one.</p>
<p>If you wish to disable the play button for a code block, you can include the <code>noplayground</code> option on the code block like this:</p>
<pre><code class="language-markdown">```rust,noplayground
let mut name = String::new();
std::io::stdin().read_line(&amp;mut name).expect(&quot;failed to read line&quot;);
println!(&quot;Hello {}!&quot;, name);
```
</code></pre>
<p>Or, if you wish to disable the play button for all code blocks in your book, you can write the config to the <code>book.toml</code> like this.</p>
<pre><code class="language-toml">[output.html.playground]
runnable = false
</code></pre>
<h2 id="rust-code-block-attributes"><a class="header" href="#rust-code-block-attributes">Rust code block attributes</a></h2>
<p>Additional attributes can be included in Rust code blocks with comma, space, or tab-separated terms just after the language term. For example:</p>
<pre><code class="language-markdown">```rust,ignore
# This example won't be tested.
panic!(&quot;oops!&quot;);
```
</code></pre>
<p>These are particularly important when using <a href="format/../cli/test.html"><code>mdbook test</code></a> to test Rust examples.
These use the same attributes as <a href="https://doc.rust-lang.org/rustdoc/documentation-tests.html#attributes">rustdoc attributes</a>, with a few additions:</p>
<ul>
<li><code>editable</code> — Enables the <a href="format/theme/editor.html">editor</a>.</li>
<li><code>noplayground</code> — Removes the play button, but will still be tested.</li>
<li><code>mdbook-runnable</code> — Forces the play button to be displayed.
This is intended to be combined with the <code>ignore</code> attribute for examples that should not be tested, but you want to allow the reader to run.</li>
<li><code>ignore</code> — Will not be tested and no play button is shown, but it is still highlighted as Rust syntax.</li>
<li><code>should_panic</code> — When executed, it should produce a panic.</li>
<li><code>no_run</code> — The code is compiled when tested, but it is not run.
The play button is also not shown.</li>
<li><code>compile_fail</code> — The code should fail to compile.</li>
<li><code>edition2015</code>, <code>edition2018</code>, <code>edition2021</code> — Forces the use of a specific Rust edition.
See <a href="format/configuration/general.html#rust-options"><code>rust.edition</code></a> to set this globally.</li>
</ul>
<h2 id="including-files"><a class="header" href="#including-files">Including files</a></h2>
<p>With the following syntax, you can include files into your book:</p>
<pre><code class="language-hbs">{{#include file.rs}}
</code></pre>
<p>The path to the file has to be relative from the current source file.</p>
<p>mdBook will interpret included files as Markdown. Since the include command
is usually used for inserting code snippets and examples, you will often
wrap the command with <code>```</code> to display the file contents without
interpreting them.</p>
<pre><code class="language-hbs">```
{{#include file.rs}}
```
</code></pre>
<h2 id="including-portions-of-a-file"><a class="header" href="#including-portions-of-a-file">Including portions of a file</a></h2>
<p>Often you only need a specific part of the file, e.g. relevant lines for an
example. We support four different modes of partial includes:</p>
<pre><code class="language-hbs">{{#include file.rs:2}}
{{#include file.rs::10}}
{{#include file.rs:2:}}
{{#include file.rs:2:10}}
</code></pre>
<p>The first command only includes the second line from file <code>file.rs</code>. The second
command includes all lines up to line 10, i.e. the lines from 11 till the end of
the file are omitted. The third command includes all lines from line 2, i.e. the
first line is omitted. The last command includes the excerpt of <code>file.rs</code>
consisting of lines 2 to 10.</p>
<p>To avoid breaking your book when modifying included files, you can also
include a specific section using anchors instead of line numbers.
An anchor is a pair of matching lines. The line beginning an anchor must
match the regex <code>ANCHOR:\s*[\w_-]+</code> and similarly the ending line must match
the regex <code>ANCHOR_END:\s*[\w_-]+</code>. This allows you to put anchors in
any kind of commented line.</p>
<p>Consider the following file to include:</p>
<pre><code class="language-rs">/* ANCHOR: all */

// ANCHOR: component
struct Paddle {
    hello: f32,
}
// ANCHOR_END: component

////////// ANCHOR: system
impl System for MySystem { ... }
////////// ANCHOR_END: system

/* ANCHOR_END: all */
</code></pre>
<p>Then in the book, all you have to do is:</p>
<pre><code class="language-hbs">Here is a component:
```rust,no_run,noplayground
{{#include file.rs:component}}
```

Here is a system:
```rust,no_run,noplayground
{{#include file.rs:system}}
```

This is the full file.
```rust,no_run,noplayground
{{#include file.rs:all}}
```
</code></pre>
<p>Lines containing anchor patterns inside the included anchor are ignored.</p>
<h2 id="including-a-file-but-initially-hiding-all-except-specified-lines"><a class="header" href="#including-a-file-but-initially-hiding-all-except-specified-lines">Including a file but initially hiding all except specified lines</a></h2>
<p>The <code>rustdoc_include</code> helper is for including code from external Rust files that contain complete
examples, but only initially showing particular lines specified with line numbers or anchors in the
same way as with <code>include</code>.</p>
<p>The lines not in the line number range or between the anchors will still be included, but they will
be prefaced with <code>#</code>. This way, a reader can expand the snippet to see the complete example, and
Rustdoc will use the complete example when you run <code>mdbook test</code>.</p>
<p>For example, consider a file named <code>file.rs</code> that contains this Rust program:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    let x = add_one(2);
    assert_eq!(x, 3);
}

fn add_one(num: i32) -&gt; i32 {
    num + 1
}
</code></pre></pre>
<p>We can include a snippet that initially shows only line 2 by using this syntax:</p>
<pre><code class="language-hbs">To call the `add_one` function, we pass it an `i32` and bind the returned value to `x`:

```rust
{{#rustdoc_include file.rs:2}}
```
</code></pre>
<p>This would have the same effect as if we had manually inserted the code and hidden all but line 2
using <code>#</code>:</p>
<pre><code class="language-hbs">To call the `add_one` function, we pass it an `i32` and bind the returned value to `x`:

```rust
# fn main() {
    let x = add_one(2);
#     assert_eq!(x, 3);
# }
#
# fn add_one(num: i32) -&gt; i32 {
#     num + 1
# }
```
</code></pre>
<p>That is, it looks like this (click the &quot;expand&quot; icon to see the rest of the file):</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">fn main() {
</span>    let x = add_one(2);
<span class="boring">    assert_eq!(x, 3);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn add_one(num: i32) -&gt; i32 {
</span><span class="boring">    num + 1
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="inserting-runnable-rust-files"><a class="header" href="#inserting-runnable-rust-files">Inserting runnable Rust files</a></h2>
<p>With the following syntax, you can insert runnable Rust files into your book:</p>
<pre><code class="language-hbs">{{#playground file.rs}}
</code></pre>
<p>The path to the Rust file has to be relative from the current source file.</p>
<p>When play is clicked, the code snippet will be sent to the <a href="https://play.rust-lang.org/">Rust Playground</a> to be
compiled and run. The result is sent back and displayed directly underneath the
code.</p>
<p>Here is what a rendered code snippet looks like:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    println!(&quot;Hello World!&quot;);
<span class="boring">
</span><span class="boring">    // You can even hide lines! :D
</span><span class="boring">    println!(&quot;I am hidden! Expand the code snippet to see me&quot;);
</span>}
</code></pre></pre>
<p>Any additional values passed after the filename will be included as attributes of the code block.
For example <code>{{#playground example.rs editable}}</code> will create the code block like the following:</p>
<pre><code class="language-markdown">```rust,editable
# Contents of example.rs here.
```
</code></pre>
<p>And the <code>editable</code> attribute will enable the <a href="format/theme/editor.html">editor</a> as described at <a href="format/mdbook.html#rust-code-block-attributes">Rust code block attributes</a>.</p>
<h2 id="controlling-page-title"><a class="header" href="#controlling-page-title">Controlling page &lt;title&gt;</a></h2>
<p>A chapter can set a &lt;title&gt; that is different from its entry in the table of
contents (sidebar) by including a <code>{{#title ...}}</code> near the top of the page.</p>
<pre><code class="language-hbs">{{#title My Title}}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="markdown"><a class="header" href="#markdown">Markdown</a></h1>
<p>mdBook's <a href="https://github.com/raphlinus/pulldown-cmark">parser</a> adheres to the <a href="https://commonmark.org/">CommonMark</a> specification with some extensions described below.
You can take a quick <a href="https://commonmark.org/help/tutorial/">tutorial</a>,
or <a href="https://spec.commonmark.org/dingus/">try out</a> CommonMark in real time. A complete Markdown overview is out of scope for 
this documentation, but below is a high level overview of some of the basics. For a more in-depth experience, check out the
<a href="https://www.markdownguide.org">Markdown Guide</a>.</p>
<h2 id="text-and-paragraphs"><a class="header" href="#text-and-paragraphs">Text and Paragraphs</a></h2>
<p>Text is rendered relatively predictably: </p>
<pre><code class="language-markdown">Here is a line of text.

This is a new line.
</code></pre>
<p>Will look like you might expect:</p>
<p>Here is a line of text.</p>
<p>This is a new line.</p>
<h2 id="headings"><a class="header" href="#headings">Headings</a></h2>
<p>Headings use the <code>#</code> marker and should be on a line by themselves. More <code>#</code> mean smaller headings:</p>
<pre><code class="language-markdown">### A heading 

Some text.

#### A smaller heading 

More text.
</code></pre>
<h3 id="a-heading"><a class="header" href="#a-heading">A heading</a></h3>
<p>Some text.</p>
<h4 id="a-smaller-heading"><a class="header" href="#a-smaller-heading">A smaller heading</a></h4>
<p>More text.</p>
<h2 id="lists"><a class="header" href="#lists">Lists</a></h2>
<p>Lists can be unordered or ordered. Ordered lists will order automatically:</p>
<pre><code class="language-markdown">* milk
* eggs
* butter

1. carrots
1. celery
1. radishes
</code></pre>
<ul>
<li>milk</li>
<li>eggs</li>
<li>butter</li>
</ul>
<ol>
<li>carrots</li>
<li>celery</li>
<li>radishes</li>
</ol>
<h2 id="links"><a class="header" href="#links">Links</a></h2>
<p>Linking to a URL or local file is easy:</p>
<pre><code class="language-markdown">Use [mdBook](https://github.com/rust-lang/mdBook). 

Read about [mdBook](mdBook.md).

A bare url: &lt;https://www.rust-lang.org&gt;.
</code></pre>
<p>Use <a href="https://github.com/rust-lang/mdBook">mdBook</a>. </p>
<p>Read about <a href="format/mdBook.html">mdBook</a>.</p>
<p>A bare url: <a href="https://www.rust-lang.org">https://www.rust-lang.org</a>.</p>
<hr />
<p>Relative links that end with <code>.md</code> will be converted to the <code>.html</code> extension.
It is recommended to use <code>.md</code> links when possible.
This is useful when viewing the Markdown file outside of mdBook, for example on GitHub or GitLab which render Markdown automatically.</p>
<p>Links to <code>README.md</code> will be converted to <code>index.html</code>.
This is done since some services like GitHub render README files automatically, but web servers typically expect the root file to be called <code>index.html</code>.</p>
<p>You can link to individual headings with <code>#</code> fragments.
For example, <code>mdbook.md#text-and-paragraphs</code> would link to the <a href="format/markdown.html#text-and-paragraphs">Text and Paragraphs</a> section above.
The ID is created by transforming the heading such as converting to lowercase and replacing spaces with dashes.
You can click on any heading and look at the URL in your browser to see what the fragment looks like.</p>
<h2 id="images"><a class="header" href="#images">Images</a></h2>
<p>Including images is simply a matter of including a link to them, much like in the <em>Links</em> section above. The following markdown
includes the Rust logo SVG image found in the <code>images</code> directory at the same level as this file:</p>
<pre><code class="language-markdown">![The Rust Logo](images/rust-logo-blk.svg)
</code></pre>
<p>Produces the following HTML when built with mdBook:</p>
<pre><code class="language-html">&lt;p&gt;&lt;img src=&quot;images/rust-logo-blk.svg&quot; alt=&quot;The Rust Logo&quot; /&gt;&lt;/p&gt;
</code></pre>
<p>Which, of course displays the image like so:</p>
<p><img src="format/images/rust-logo-blk.svg" alt="The Rust Logo" /></p>
<h2 id="extensions"><a class="header" href="#extensions">Extensions</a></h2>
<p>mdBook has several extensions beyond the standard CommonMark specification.</p>
<h3 id="strikethrough"><a class="header" href="#strikethrough">Strikethrough</a></h3>
<p>Text may be rendered with a horizontal line through the center by wrapping the
text with two tilde characters on each side:</p>
<pre><code class="language-text">An example of ~~strikethrough text~~.
</code></pre>
<p>This example will render as:</p>
<blockquote>
<p>An example of <del>strikethrough text</del>.</p>
</blockquote>
<p>This follows the <a href="https://github.github.com/gfm/#strikethrough-extension-">GitHub Strikethrough extension</a>.</p>
<h3 id="footnotes"><a class="header" href="#footnotes">Footnotes</a></h3>
<p>A footnote generates a small numbered link in the text which when clicked
takes the reader to the footnote text at the bottom of the item. The footnote
label is written similarly to a link reference with a caret at the front. The
footnote text is written like a link reference definition, with the text
following the label. Example:</p>
<pre><code class="language-text">This is an example of a footnote[^note].

[^note]: This text is the contents of the footnote, which will be rendered
    towards the bottom.
</code></pre>
<p>This example will render as:</p>
<blockquote>
<p>This is an example of a footnote<sup class="footnote-reference"><a href="#note">1</a></sup>.</p>
<div class="footnote-definition" id="note"><sup class="footnote-definition-label">1</sup>
<p>This text is the contents of the footnote, which will be rendered
towards the bottom.</p>
</div>
</blockquote>
<p>The footnotes are automatically numbered based on the order the footnotes are
written.</p>
<h3 id="tables"><a class="header" href="#tables">Tables</a></h3>
<p>Tables can be written using pipes and dashes to draw the rows and columns of
the table. These will be translated to HTML table matching the shape. Example:</p>
<pre><code class="language-text">| Header1 | Header2 |
|---------|---------|
| abc     | def     |
</code></pre>
<p>This example will render similarly to this:</p>
<table><thead><tr><th>Header1</th><th>Header2</th></tr></thead><tbody>
<tr><td>abc</td><td>def</td></tr>
</tbody></table>
<p>See the specification for the <a href="https://github.github.com/gfm/#tables-extension-">GitHub Tables extension</a> for more
details on the exact syntax supported.</p>
<h3 id="task-lists"><a class="header" href="#task-lists">Task lists</a></h3>
<p>Task lists can be used as a checklist of items that have been completed.
Example:</p>
<pre><code class="language-md">- [x] Complete task
- [ ] Incomplete task
</code></pre>
<p>This will render as:</p>
<blockquote>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Complete task</li>
<li><input disabled="" type="checkbox"/>
Incomplete task</li>
</ul>
</blockquote>
<p>See the specification for the <a href="https://github.github.com/gfm/#task-list-items-extension-">task list extension</a> for more details.</p>
<h3 id="smart-punctuation"><a class="header" href="#smart-punctuation">Smart punctuation</a></h3>
<p>Some ASCII punctuation sequences will be automatically turned into fancy Unicode
characters:</p>
<table><thead><tr><th>ASCII sequence</th><th>Unicode</th></tr></thead><tbody>
<tr><td><code>--</code></td><td>–</td></tr>
<tr><td><code>---</code></td><td>—</td></tr>
<tr><td><code>...</code></td><td>…</td></tr>
<tr><td><code>&quot;</code></td><td>“ or ”, depending on context</td></tr>
<tr><td><code>'</code></td><td>‘ or ’, depending on context</td></tr>
</tbody></table>
<p>So, no need to manually enter those Unicode characters!</p>
<p>This feature is disabled by default.
To enable it, see the <a href="format/configuration/renderers.html#html-renderer-options"><code>output.html.curly-quotes</code></a> config option.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-mdbook-in-continuous-integration"><a class="header" href="#running-mdbook-in-continuous-integration">Running <code>mdbook</code> in Continuous Integration</a></h1>
<p>There are a variety of services such as <a href="https://docs.github.com/en/actions">GitHub Actions</a> or <a href="https://docs.gitlab.com/ee/ci/">GitLab CI/CD</a> which can be used to test and deploy your book automatically.</p>
<p>The following provides some general guidelines on how to configure your service to run mdBook.
Specific recipes can be found at the <a href="https://github.com/rust-lang/mdBook/wiki/Automated-Deployment">Automated Deployment</a> wiki page.</p>
<h2 id="installing-mdbook"><a class="header" href="#installing-mdbook">Installing mdBook</a></h2>
<p>There are several different strategies for installing mdBook.
The particular method depends on your needs and preferences.</p>
<h3 id="pre-compiled-binaries"><a class="header" href="#pre-compiled-binaries">Pre-compiled binaries</a></h3>
<p>Perhaps the easiest method is to use the pre-compiled binaries found on the <a href="https://github.com/rust-lang/mdBook/releases">GitHub Releases page</a>.
A simple approach would be to use the popular <code>curl</code> CLI tool to download the executable:</p>
<pre><code class="language-sh">mkdir bin
curl -sSL https://github.com/rust-lang/mdBook/releases/download/v0.4.18/mdbook-v0.4.18-x86_64-unknown-linux-gnu.tar.gz | tar -xz --directory=bin
bin/mdbook build
</code></pre>
<p>Some considerations for this approach:</p>
<ul>
<li>This is relatively fast, and does not necessarily require dealing with caching.</li>
<li>This does not require installing Rust.</li>
<li>Specifying a specific URL means you have to manually update your script to get a new version.
This may be a benefit if you want to lock to a specific version.
However, some users prefer to automatically get a newer version when they are published.</li>
<li>You are reliant on the GitHub CDN being available.</li>
</ul>
<h3 id="building-from-source"><a class="header" href="#building-from-source">Building from source</a></h3>
<p>Building from source will require having Rust installed.
Some services have Rust pre-installed, but if your service does not, you will need to add a step to install it.</p>
<p>After Rust is installed, <code>cargo install</code> can be used to build and install mdBook.
We recommend using a SemVer version specifier so that you get the latest <strong>non-breaking</strong> version of mdBook.
For example:</p>
<pre><code class="language-sh">cargo install mdbook --no-default-features --features search --vers &quot;^0.4&quot; --locked
</code></pre>
<p>This includes several recommended options:</p>
<ul>
<li><code>--no-default-features</code> — Disables features like the HTTP server used by <code>mdbook serve</code> that is likely not needed on CI.
This will speed up the build time significantly.</li>
<li><code>--features search</code> — Disabling default features means you should then manually enable features that you want, such as the built-in <a href="guide/reading.html#search">search</a> capability.</li>
<li><code>--vers &quot;^0.4&quot;</code> — This will install the most recent version of the <code>0.4</code> series.
However, versions after like <code>0.5.0</code> won't be installed, as they may break your build.
Cargo will automatically upgrade mdBook if you have an older version already installed.</li>
<li><code>--locked</code> — This will use the dependencies that were used when mdBook was released.
Without <code>--locked</code>, it will use the latest version of all dependencies, which may include some fixes since the last release, but may also (rarely) cause build problems.</li>
</ul>
<p>You will likely want to investigate caching options, as building mdBook can be somewhat slow.</p>
<h2 id="running-tests"><a class="header" href="#running-tests">Running tests</a></h2>
<p>You may want to run tests using <a href="cli/test.html"><code>mdbook test</code></a> every time you push a change or create a pull request.
This can be used to validate Rust code examples in the book.</p>
<p>This will require having Rust installed.
Some services have Rust pre-installed, but if your service does not, you will need to add a step to install it.</p>
<p>Other than making sure the appropriate version of Rust is installed, there's not much more than just running <code>mdbook test</code> from the book directory.</p>
<p>You may also want to consider running other kinds of tests, like <a href="https://github.com/Michael-F-Bryan/mdbook-linkcheck#continuous-integration">mdbook-linkcheck</a> which will check for broken links.
Or if you have your own style checks, spell checker, or any other tests it might be good to run them in CI.</p>
<h2 id="deploying"><a class="header" href="#deploying">Deploying</a></h2>
<p>You may want to automatically deploy your book.
Some may want to do this with every time a change is pushed, and others may want to only deploy when a specific release is tagged.</p>
<p>You'll also need to understand the specifics on how to push a change to your web service.
For example, <a href="https://docs.github.com/en/pages">GitHub Pages</a> just requires committing the output onto a specific git branch.
Other services may require using something like SSH to connect to a remote server.</p>
<p>The basic outline is that you need to run <code>mdbook build</code> to generate the output, and then transfer the files (which are in the <code>book</code> directory) to the correct location.</p>
<p>You may then want to consider if you need to invalidate any caches on your web service.</p>
<p>See the <a href="https://github.com/rust-lang/mdBook/wiki/Automated-Deployment">Automated Deployment</a> wiki page for examples of various different services.</p>
<h3 id="404-handling"><a class="header" href="#404-handling">404 handling</a></h3>
<p>mdBook automatically generates a 404 page to be used for broken links.
The default output is a file named <code>404.html</code> at the root of the book.
Some services like <a href="https://docs.github.com/en/pages">GitHub Pages</a> will automatically use this page for broken links.
For other services, you may want to consider configuring the web server to use this page as it will provide the reader navigation to get back to the book.</p>
<p>If your book is not deployed at the root of the domain, then you should set the <a href="format/configuration/renderers.html#html-renderer-options"><code>output.html.site-url</code></a> setting so that the 404 page works correctly.
It needs to know where the book is deployed in order to load the static files (like CSS) correctly.
For example, this guide is deployed at <a href="https://rust-lang.github.io/mdBook/">https://rust-lang.github.io/mdBook/</a>, and the <code>site-url</code> setting is configured like this:</p>
<pre><code class="language-toml"># book.toml
[output.html]
site-url = &quot;/mdBook/&quot;
</code></pre>
<p>You can customize the look of the 404 page by creating a file named <code>src/404.md</code> in your book.
If you want to use a different filename, you can set <a href="format/configuration/renderers.html#html-renderer-options"><code>output.html.input-404</code></a> to a different filename.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for-developers"><a class="header" href="#for-developers">For Developers</a></h1>
<p>While <code>mdbook</code> is mainly used as a command line tool, you can also import the
underlying library directly and use that to manage a book. It also has a fairly
flexible plugin mechanism, allowing you to create your own custom tooling and
consumers (often referred to as <em>backends</em>) if you need to do some analysis of
the book or render it in a different format.</p>
<p>The <em>For Developers</em> chapters are here to show you the more advanced usage of
<code>mdbook</code>.</p>
<p>The two main ways a developer can hook into the book's build process is via,</p>
<ul>
<li><a href="for_developers/preprocessors.html">Preprocessors</a></li>
<li><a href="for_developers/backends.html">Alternative Backends</a></li>
</ul>
<h2 id="the-build-process"><a class="header" href="#the-build-process">The Build Process</a></h2>
<p>The process of rendering a book project goes through several steps.</p>
<ol>
<li>Load the book
<ul>
<li>Parse the <code>book.toml</code>, falling back to the default <code>Config</code> if it doesn't
exist</li>
<li>Load the book chapters into memory</li>
<li>Discover which preprocessors/backends should be used</li>
</ul>
</li>
<li>For each backend:
<ol>
<li>Run all the preprocessors.</li>
<li>Call the backend to render the processed result.</li>
</ol>
</li>
</ol>
<h2 id="using-mdbook-as-a-library"><a class="header" href="#using-mdbook-as-a-library">Using <code>mdbook</code> as a Library</a></h2>
<p>The <code>mdbook</code> binary is just a wrapper around the <code>mdbook</code> crate, exposing its
functionality as a command-line program. As such it is quite easy to create your
own programs which use <code>mdbook</code> internally, adding your own functionality (e.g.
a custom preprocessor) or tweaking the build process.</p>
<p>The easiest way to find out how to use the <code>mdbook</code> crate is by looking at the
<a href="https://docs.rs/mdbook/*/mdbook/">API Docs</a>. The top level documentation explains how one would use the
<a href="https://docs.rs/mdbook/*/mdbook/book/struct.MDBook.html"><code>MDBook</code></a> type to load and build a book, while the <a href="https://docs.rs/mdbook/*/mdbook/config/index.html">config</a> module gives a good
explanation on the configuration system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preprocessors"><a class="header" href="#preprocessors">Preprocessors</a></h1>
<p>A <em>preprocessor</em> is simply a bit of code which gets run immediately after the
book is loaded and before it gets rendered, allowing you to update and mutate
the book. Possible use cases are:</p>
<ul>
<li>Creating custom helpers like <code>{{#include /path/to/file.md}}</code></li>
<li>Substituting in latex-style expressions (<code>$$ \frac{1}{3} $$</code>) with their
mathjax equivalents</li>
</ul>
<p>See <a href="for_developers/../format/configuration/preprocessors.html">Configuring Preprocessors</a> for more information about using preprocessors.</p>
<h2 id="hooking-into-mdbook"><a class="header" href="#hooking-into-mdbook">Hooking Into MDBook</a></h2>
<p>MDBook uses a fairly simple mechanism for discovering third party plugins.
A new table is added to <code>book.toml</code> (e.g. <code>[preprocessor.foo]</code> for the <code>foo</code>
preprocessor) and then <code>mdbook</code> will try to invoke the <code>mdbook-foo</code> program as
part of the build process.</p>
<p>Once the preprocessor has been defined and the build process starts, mdBook executes the command defined in the <code>preprocessor.foo.command</code> key twice.
The first time it runs the preprocessor to determine if it supports the given renderer.
mdBook passes two arguments to the process: the first argument is the string <code>supports</code> and the second argument is the renderer name.
The preprocessor should exit with a status code 0 if it supports the given renderer, or return a non-zero exit code if it does not.</p>
<p>If the preprocessor supports the renderer, then mdbook runs it a second time, passing JSON data into stdin.
The JSON consists of an array of <code>[context, book]</code> where <code>context</code> is the serialized object <a href="https://docs.rs/mdbook/latest/mdbook/preprocess/struct.PreprocessorContext.html"><code>PreprocessorContext</code></a> and <code>book</code> is a <a href="https://docs.rs/mdbook/latest/mdbook/book/struct.Book.html"><code>Book</code></a> object containing the content of the book.</p>
<p>The preprocessor should return the JSON format of the <a href="https://docs.rs/mdbook/latest/mdbook/book/struct.Book.html"><code>Book</code></a> object to stdout, with any modifications it wishes to perform.</p>
<p>The easiest way to get started is by creating your own implementation of the
<code>Preprocessor</code> trait (e.g. in <code>lib.rs</code>) and then creating a shell binary which
translates inputs to the correct <code>Preprocessor</code> method. For convenience, there
is <a href="https://github.com/rust-lang/mdBook/blob/master/examples/nop-preprocessor.rs">an example no-op preprocessor</a> in the <code>examples/</code> directory which can easily
be adapted for other preprocessors.</p>
<details>
<summary>Example no-op preprocessor</summary>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// nop-preprocessors.rs

{{#include ../../../examples/nop-preprocessor.rs}}
<span class="boring">}
</span></code></pre></pre>
</details>
<h2 id="hints-for-implementing-a-preprocessor"><a class="header" href="#hints-for-implementing-a-preprocessor">Hints For Implementing A Preprocessor</a></h2>
<p>By pulling in <code>mdbook</code> as a library, preprocessors can have access to the
existing infrastructure for dealing with books.</p>
<p>For example, a custom preprocessor could use the
<a href="https://docs.rs/mdbook/latest/mdbook/preprocess/trait.Preprocessor.html#method.parse_input"><code>CmdPreprocessor::parse_input()</code></a> function to deserialize the JSON written to
<code>stdin</code>. Then each chapter of the <code>Book</code> can be mutated in-place via
<a href="https://docs.rs/mdbook/latest/mdbook/book/struct.Book.html#method.for_each_mut"><code>Book::for_each_mut()</code></a>, and then written to <code>stdout</code> with the <code>serde_json</code>
crate.</p>
<p>Chapters can be accessed either directly (by recursively iterating over
chapters) or via the <code>Book::for_each_mut()</code> convenience method.</p>
<p>The <code>chapter.content</code> is just a string which happens to be markdown. While it's
entirely possible to use regular expressions or do a manual find &amp; replace,
you'll probably want to process the input into something more computer-friendly.
The <a href="https://crates.io/crates/pulldown-cmark"><code>pulldown-cmark</code></a> crate implements a production-quality event-based
Markdown parser, with the <a href="https://crates.io/crates/pulldown-cmark-to-cmark"><code>pulldown-cmark-to-cmark</code></a> crate allowing you to
translate events back into markdown text.</p>
<p>The following code block shows how to remove all emphasis from markdown,
without accidentally breaking the document.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn remove_emphasis(
    num_removed_items: &amp;mut usize,
    chapter: &amp;mut Chapter,
) -&gt; Result&lt;String&gt; {
    let mut buf = String::with_capacity(chapter.content.len());

    let events = Parser::new(&amp;chapter.content).filter(|e| {
        let should_keep = match *e {
            Event::Start(Tag::Emphasis)
            | Event::Start(Tag::Strong)
            | Event::End(Tag::Emphasis)
            | Event::End(Tag::Strong) =&gt; false,
            _ =&gt; true,
        };
        if !should_keep {
            *num_removed_items += 1;
        }
        should_keep
    });

    cmark(events, &amp;mut buf, None).map(|_| buf).map_err(|err| {
        Error::from(format!(&quot;Markdown serialization failed: {}&quot;, err))
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>For everything else, have a look <a href="https://github.com/rust-lang/mdBook/blob/master/examples/nop-preprocessor.rs">at the complete example</a>.</p>
<h2 id="implementing-a-preprocessor-with-a-different-language"><a class="header" href="#implementing-a-preprocessor-with-a-different-language">Implementing a preprocessor with a different language</a></h2>
<p>The fact that mdBook utilizes stdin and stdout to communicate with the preprocessors makes it easy to implement them in a language other than Rust.
The following code shows how to implement a simple preprocessor in Python, which will modify the content of the first chapter.
The example below follows the configuration shown above with <code>preprocessor.foo.command</code> actually pointing to a Python script.</p>
<pre><code class="language-python">import json
import sys


if __name__ == '__main__':
    if len(sys.argv) &gt; 1: # we check if we received any argument
        if sys.argv[1] == &quot;supports&quot;: 
            # then we are good to return an exit status code of 0, since the other argument will just be the renderer's name
            sys.exit(0)

    # load both the context and the book representations from stdin
    context, book = json.load(sys.stdin)
    # and now, we can just modify the content of the first chapter
    book['sections'][0]['Chapter']['content'] = '# Hello'
    # we are done with the book's modification, we can just print it to stdout, 
    print(json.dumps(book))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alternative-backends"><a class="header" href="#alternative-backends">Alternative Backends</a></h1>
<p>A &quot;backend&quot; is simply a program which <code>mdbook</code> will invoke during the book
rendering process. This program is passed a JSON representation of the book and
configuration information via <code>stdin</code>. Once the backend receives this
information it is free to do whatever it wants.</p>
<p>See <a href="for_developers/../format/configuration/renderers.html">Configuring Renderers</a> for more information about using backends.</p>
<p>The community has developed several backends.
See the <a href="https://github.com/rust-lang/mdBook/wiki/Third-party-plugins">Third Party Plugins</a> wiki page for a list of available backends.</p>
<h2 id="setting-up"><a class="header" href="#setting-up">Setting Up</a></h2>
<p>This page will step you through creating your own alternative backend in the form
of a simple word counting program. Although it will be written in Rust, there's
no reason why it couldn't be accomplished using something like Python or Ruby.</p>
<p>First you'll want to create a new binary program and add <code>mdbook</code> as a
dependency.</p>
<pre><code class="language-shell">$ cargo new --bin mdbook-wordcount
$ cd mdbook-wordcount
$ cargo add mdbook
</code></pre>
<p>When our <code>mdbook-wordcount</code> plugin is invoked, <code>mdbook</code> will send it a JSON
version of <a href="https://docs.rs/mdbook/*/mdbook/renderer/struct.RenderContext.html"><code>RenderContext</code></a> via our plugin's <code>stdin</code>. For convenience, there's
a <a href="https://docs.rs/mdbook/*/mdbook/renderer/struct.RenderContext.html#method.from_json"><code>RenderContext::from_json()</code></a> constructor which will load a <code>RenderContext</code>.</p>
<p>This is all the boilerplate necessary for our backend to load the book.</p>
<pre><pre class="playground"><code class="language-rust edition2018">// src/main.rs
extern crate mdbook;

use std::io;
use mdbook::renderer::RenderContext;

fn main() {
    let mut stdin = io::stdin();
    let ctx = RenderContext::from_json(&amp;mut stdin).unwrap();
}
</code></pre></pre>
<blockquote>
<p><strong>Note:</strong> The <code>RenderContext</code> contains a <code>version</code> field. This lets backends
figure out whether they are compatible with the version of <code>mdbook</code> it's being
called by. This <code>version</code> comes directly from the corresponding field in
<code>mdbook</code>'s <code>Cargo.toml</code>.</p>
</blockquote>
<p>It is recommended that backends use the <a href="https://crates.io/crates/semver"><code>semver</code></a> crate to inspect this field
and emit a warning if there may be a compatibility issue.</p>
<h2 id="inspecting-the-book"><a class="header" href="#inspecting-the-book">Inspecting the Book</a></h2>
<p>Now our backend has a copy of the book, lets count how many words are in each
chapter!</p>
<p>Because the <code>RenderContext</code> contains a <a href="https://docs.rs/mdbook/*/mdbook/book/struct.Book.html"><code>Book</code></a> field (<code>book</code>), and a <code>Book</code> has
the <a href="https://docs.rs/mdbook/*/mdbook/book/struct.Book.html#method.iter"><code>Book::iter()</code></a> method for iterating over all items in a <code>Book</code>, this step
turns out to be just as easy as the first.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
fn main() {
    let mut stdin = io::stdin();
    let ctx = RenderContext::from_json(&amp;mut stdin).unwrap();

    for item in ctx.book.iter() {
        if let BookItem::Chapter(ref ch) = *item {
            let num_words = count_words(ch);
            println!(&quot;{}: {}&quot;, ch.name, num_words);
        }
    }
}

fn count_words(ch: &amp;Chapter) -&gt; usize {
    ch.content.split_whitespace().count()
}
</code></pre></pre>
<h2 id="enabling-the-backend"><a class="header" href="#enabling-the-backend">Enabling the Backend</a></h2>
<p>Now we've got the basics running, we want to actually use it. First, install the
program.</p>
<pre><code class="language-shell">$ cargo install --path .
</code></pre>
<p>Then <code>cd</code> to the particular book you'd like to count the words of and update its
<code>book.toml</code> file.</p>
<pre><code class="language-diff">  [book]
  title = &quot;mdBook Documentation&quot;
  description = &quot;Create book from markdown files. Like Gitbook but implemented in Rust&quot;
  authors = [&quot;Mathieu David&quot;, &quot;Michael-F-Bryan&quot;]

+ [output.html]

+ [output.wordcount]
</code></pre>
<p>When it loads a book into memory, <code>mdbook</code> will inspect your <code>book.toml</code> file to
try and figure out which backends to use by looking for all <code>output.*</code> tables.
If none are provided it'll fall back to using the default HTML renderer.</p>
<p>Notably, this means if you want to add your own custom backend you'll also need
to make sure to add the HTML backend, even if its table just stays empty.</p>
<p>Now you just need to build your book like normal, and everything should <em>Just
Work</em>.</p>
<pre><code class="language-shell">$ mdbook build
...
2018-01-16 07:31:15 [INFO] (mdbook::renderer): Invoking the &quot;mdbook-wordcount&quot; renderer
mdBook: 126
Command Line Tool: 224
init: 283
build: 145
watch: 146
serve: 292
test: 139
Format: 30
SUMMARY.md: 259
Configuration: 784
Theme: 304
index.hbs: 447
Syntax highlighting: 314
MathJax Support: 153
Rust code specific features: 148
For Developers: 788
Alternative Backends: 710
Contributors: 85
</code></pre>
<p>The reason we didn't need to specify the full name/path of our <code>wordcount</code>
backend is because <code>mdbook</code> will try to <em>infer</em> the program's name via
convention. The executable for the <code>foo</code> backend is typically called
<code>mdbook-foo</code>, with an associated <code>[output.foo]</code> entry in the <code>book.toml</code>. To
explicitly tell <code>mdbook</code> what command to invoke (it may require command-line
arguments or be an interpreted script), you can use the <code>command</code> field.</p>
<pre><code class="language-diff">  [book]
  title = &quot;mdBook Documentation&quot;
  description = &quot;Create book from markdown files. Like Gitbook but implemented in Rust&quot;
  authors = [&quot;Mathieu David&quot;, &quot;Michael-F-Bryan&quot;]

  [output.html]

  [output.wordcount]
+ command = &quot;python /path/to/wordcount.py&quot;
</code></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>Now imagine you don't want to count the number of words on a particular chapter
(it might be generated text/code, etc). The canonical way to do this is via the
usual <code>book.toml</code> configuration file by adding items to your <code>[output.foo]</code>
table.</p>
<p>The <code>Config</code> can be treated roughly as a nested hashmap which lets you call
methods like <code>get()</code> to access the config's contents, with a
<code>get_deserialized()</code> convenience method for retrieving a value and automatically
deserializing to some arbitrary type <code>T</code>.</p>
<p>To implement this, we'll create our own serializable <code>WordcountConfig</code> struct
which will encapsulate all configuration for this backend.</p>
<p>First add <code>serde</code> and <code>serde_derive</code> to your <code>Cargo.toml</code>,</p>
<pre><code>$ cargo add serde serde_derive
</code></pre>
<p>And then you can create the config struct,</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate serde;
#[macro_use]
extern crate serde_derive;

...

#[derive(Debug, Default, Serialize, Deserialize)]
#[serde(default, rename_all = &quot;kebab-case&quot;)]
pub struct WordcountConfig {
  pub ignores: Vec&lt;String&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we just need to deserialize the <code>WordcountConfig</code> from our <code>RenderContext</code>
and then add a check to make sure we skip ignored chapters.</p>
<pre><code class="language-diff">  fn main() {
      let mut stdin = io::stdin();
      let ctx = RenderContext::from_json(&amp;mut stdin).unwrap();
+     let cfg: WordcountConfig = ctx.config
+         .get_deserialized(&quot;output.wordcount&quot;)
+         .unwrap_or_default();

      for item in ctx.book.iter() {
          if let BookItem::Chapter(ref ch) = *item {
+             if cfg.ignores.contains(&amp;ch.name) {
+                 continue;
+             }
+
              let num_words = count_words(ch);
              println!(&quot;{}: {}&quot;, ch.name, num_words);
          }
      }
  }
</code></pre>
<h2 id="output-and-signalling-failure"><a class="header" href="#output-and-signalling-failure">Output and Signalling Failure</a></h2>
<p>While it's nice to print word counts to the terminal when a book is built, it
might also be a good idea to output them to a file somewhere. <code>mdbook</code> tells a
backend where it should place any generated output via the <code>destination</code> field
in <a href="https://docs.rs/mdbook/*/mdbook/renderer/struct.RenderContext.html"><code>RenderContext</code></a>.</p>
<pre><code class="language-diff">+ use std::fs::{self, File};
+ use std::io::{self, Write};
- use std::io;
  use mdbook::renderer::RenderContext;
  use mdbook::book::{BookItem, Chapter};

  fn main() {
    ...

+     let _ = fs::create_dir_all(&amp;ctx.destination);
+     let mut f = File::create(ctx.destination.join(&quot;wordcounts.txt&quot;)).unwrap();
+
      for item in ctx.book.iter() {
          if let BookItem::Chapter(ref ch) = *item {
              ...

              let num_words = count_words(ch);
              println!(&quot;{}: {}&quot;, ch.name, num_words);
+             writeln!(f, &quot;{}: {}&quot;, ch.name, num_words).unwrap();
          }
      }
  }
</code></pre>
<blockquote>
<p><strong>Note:</strong> There is no guarantee that the destination directory exists or is
empty (<code>mdbook</code> may leave the previous contents to let backends do caching),
so it's always a good idea to create it with <code>fs::create_dir_all()</code>.</p>
<p>If the destination directory already exists, don't assume it will be empty.
To allow backends to cache the results from previous runs, <code>mdbook</code> may leave
old content in the directory.</p>
</blockquote>
<p>There's always the possibility that an error will occur while processing a book
(just look at all the <code>unwrap()</code>'s we've written already), so <code>mdbook</code> will
interpret a non-zero exit code as a rendering failure.</p>
<p>For example, if we wanted to make sure all chapters have an <em>even</em> number of
words, erroring out if an odd number is encountered, then you may do something
like this:</p>
<pre><code class="language-diff">+ use std::process;
  ...

  fn main() {
      ...

      for item in ctx.book.iter() {
          if let BookItem::Chapter(ref ch) = *item {
              ...

              let num_words = count_words(ch);
              println!(&quot;{}: {}&quot;, ch.name, num_words);
              writeln!(f, &quot;{}: {}&quot;, ch.name, num_words).unwrap();

+             if cfg.deny_odds &amp;&amp; num_words % 2 == 1 {
+               eprintln!(&quot;{} has an odd number of words!&quot;, ch.name);
+               process::exit(1);
              }
          }
      }
  }

  #[derive(Debug, Default, Serialize, Deserialize)]
  #[serde(default, rename_all = &quot;kebab-case&quot;)]
  pub struct WordcountConfig {
      pub ignores: Vec&lt;String&gt;,
+     pub deny_odds: bool,
  }
</code></pre>
<p>Now, if we reinstall the backend and build a book,</p>
<pre><code class="language-shell">$ cargo install --path . --force
$ mdbook build /path/to/book
...
2018-01-16 21:21:39 [INFO] (mdbook::renderer): Invoking the &quot;wordcount&quot; renderer
mdBook: 126
Command Line Tool: 224
init: 283
init has an odd number of words!
2018-01-16 21:21:39 [ERROR] (mdbook::renderer): Renderer exited with non-zero return code.
2018-01-16 21:21:39 [ERROR] (mdbook::utils): Error: Rendering failed
2018-01-16 21:21:39 [ERROR] (mdbook::utils):    Caused By: The &quot;mdbook-wordcount&quot; renderer failed
</code></pre>
<p>As you've probably already noticed, output from the plugin's subprocess is
immediately passed through to the user. It is encouraged for plugins to follow
the &quot;rule of silence&quot; and only generate output when necessary (e.g. an error in
generation or a warning).</p>
<p>All environment variables are passed through to the backend, allowing you to use
the usual <code>RUST_LOG</code> to control logging verbosity.</p>
<h2 id="wrapping-up"><a class="header" href="#wrapping-up">Wrapping Up</a></h2>
<p>Although contrived, hopefully this example was enough to show how you'd create
an alternative backend for <code>mdbook</code>. If you feel it's missing something, don't
hesitate to create an issue in the <a href="https://github.com/rust-lang/mdBook/issues">issue tracker</a> so we can improve the user
guide.</p>
<p>The existing backends mentioned towards the start of this chapter should serve
as a good example of how it's done in real life, so feel free to skim through
the source code or ask questions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>
<p>Here is a list of the contributors who have helped improving mdBook. Big
shout-out to them!</p>
<ul>
<li><a href="https://github.com/mdinger">mdinger</a></li>
<li>Kevin (<a href="https://github.com/kbknapp">kbknapp</a>)</li>
<li>Steve Klabnik (<a href="https://github.com/steveklabnik">steveklabnik</a>)</li>
<li>Adam Solove (<a href="https://github.com/asolove">asolove</a>)</li>
<li>Wayne Nilsen (<a href="https://github.com/waynenilsen">waynenilsen</a>)</li>
<li><a href="https://github.com/funkill">funnkill</a></li>
<li>Fu Gangqiang (<a href="https://github.com/FuGangqiang">FuGangqiang</a>)</li>
<li><a href="https://github.com/Michael-F-Bryan">Michael-F-Bryan</a></li>
<li>Chris Spiegel (<a href="https://github.com/cspiegel">cspiegel</a>)</li>
<li><a href="https://github.com/projektir">projektir</a></li>
<li><a href="https://github.com/Phaiax">Phaiax</a></li>
<li>Matt Ickstadt (<a href="https://github.com/mattico">mattico</a>)</li>
<li>Weihang Lo (<a href="https://github.com/weihanglo">weihanglo</a>)</li>
<li>Avision Ho (<a href="https://github.com/avisionh">avisionh</a>)</li>
<li>Vivek Akupatni (<a href="https://github.com/apatniv">apatniv</a>)</li>
<li>Eric Huss (<a href="https://github.com/ehuss">ehuss</a>)</li>
<li>Josh Rotenberg (<a href="https://github.com/joshrotenberg">joshrotenberg</a>)</li>
</ul>
<p>If you feel you're missing from this list, feel free to add yourself in a PR.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
